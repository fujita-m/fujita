\documentclass[submit,techreq,noauthor,dvipdfmx]{ipsj}

\usepackage{graphicx}
\usepackage{dcolumn}
\usepackage{latexsym}
\usepackage{url}    % bibtex で url を使う
\urlstyle{same}     % フォントが変わる問題をなくす

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% sty/ にある研究室独自のスタイルファイル

\usepackage{jtygm}  % フォントに関する余計な警告を消す
\usepackage{nutils} % insertfigure, figef, tabref マクロ

\def\figdir{./figs} % 図のディレクトリ
\def\figext{pdf}    % 図のファイルの拡張子

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 文字に関するマクロ

\def\DesktopBookmark{\mbox{Desktop} \mbox{Bookmark}}
\def\DTB{\mbox{DTB}}
\def\WorkState{\mbox{Time} \mbox{Entry}}
\def\Task{\mbox{Task}}
\def\Recurrence{\mbox{Recurrence}}
\def\Mission{\mbox{Mission}}
\def\Job{\mbox{Job}}
\def\Duration{\mbox{Duration}}
\def\TimeEntry{\mbox{Time} \mbox{Entry}}
\def\UnifiedHistory{\mbox{Unified} \mbox{History}}
\newcommand{\Info}[1]{\mbox{（情報#1）}}
\newcommand{\Source}[1]{\mbox{（情報源#1）}}
\newcommand{\Step}[2]{\mbox{（手順#1-#2）}}
\newcommand{\Number}[1]{\mbox{（通番#1）}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}

\setcounter{巻数}{1}%vol53=2012
\setcounter{号数}{1}
\setcounter{page}{1}

\begin{document}

\title{Mintオペレーティングシステムを用いた\\NICドライバの開発支援手法の実現}

\affiliate{OU}{岡山大学大学院自然科学研究科\\
Graduate School of Natural Science and Technology, Okayama University}

\author{藤田 将輝}{Masaki Fujita}{OU}
\author{乃村 能成}{Yoshinari Nomura}{OU}
\author{谷口 秀夫}{Hideo Taniguchi}{OU}

\begin{abstract}
    OSの機能の中でも，割込処理は非同期的に発生するため，処理の再現性が
    なく，開発が困難である．仮想計算機を用いて割込をエミュレートする開
    発手法がこれまで提案されているが，ハイパーバイザのオーバヘッドにより，
    短い間隔や一定間隔で発生する割込を再現できない．一方，我々が研究開
    発しているMintオペレーティングシステムでは，仮想化を用いずに複数のOSを
    動作させることで，上記の問題を解決する．具体的には，Mint上で動作する2
    つのOSの一方を擬似的なデバイスとし，その擬似デバイスから高速で一定周期
    の割込を発生させる．本論文では，提案手法を割込処理が多発する
    NICドライバに適用し，NICドライバの開発支援に有用であることを示す． 
\end{abstract}

\begin{jkeyword}
    仮想化，割込，開発
\end{jkeyword}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 1章 はじめに
\section{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Operating System (以下，OS)の多機能化にともなって，
OSのテストやデバッグに多くの工数を要するようになっている\cite{chou2001empirical}．
特に，非同期的な処理は，常に同じタイミングで発生しないため，再現が困難である．
この非同期的な処理の1つに割込処理がある．
割込処理の再現をする方法として，仮想計算機(以下，VM)を用いたものがある．
VMを用いることの利点は2つある．1つは1台の計算機上で開発を支援する
機構(以下，開発支援機構)と開発対象のOS(以下，開発対象OS)を
動作できることである．
これにより，計算機を2台用意するためのコストを削減できる．
もう1つは，開発支援機構を開発対象OSの外部に実装できる点である．
これにより，開発支援機構が開発対象OSの影響を受けない．
開発支援機構が開発対象OSへ割込を挿入させたり，
開発支援機構が開発対象OSの動作を再現したりすることで，
開発を支援する．
しかし，VMを用いる場合，VMとハイパーバイザ間の
処理の遷移に伴う処理負荷が存在する．
このため，VMを用いた開発支援環境では一定間隔で発生する
割込や，短い間隔で発生する割込のように，処理負荷が影響する
割込処理の再現が困難である．

そこで，マルチコアCPUの1コアを開発対象OSの外部に設置し，このコアから
開発対象OSへ割込を発生させることにより問題を解決する．
これを可能にする手段として，Multiple Independent operating systems with New Technology (以下，Mint)\cite{senzaki}
が研究開発されている．
MintはマルチコアCPUを搭載した計算機上で仮想化用いずに複数のOSを動作できる．

本研究では，提案手法を用いて非同期的な割込が頻繁に発生するNICドライバを対象とした
開発支援環境の実装について述べる．
これにより，Mintにおける割込処理の開発支援環境で，
NICドライバのテストが行えることを示す．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2章 関連研究
\section{関連研究}\label{chap:related_reserch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
%% 2.1節 VMを用いたデバッグ支援機構
\subsection{VMを用いた開発支援機構}\label{sec:debugging_support_mechanism_with_VM}
%%%%%%%%%%%%%%%%

OSの割込に関するテストを支援する環境の既存研究としてVMを用いたものがある．
既存研究は主に，バグを再現することでデバッグを支援するデバッグ支援環境として研究されている．
VMを用いた割込開発支援環境は大きく分けて2つある．
割込挿入法\cite{miyahara}とロギング/リプレイ法\cite{samuel}\cite{jim}\cite{kawasaki}\cite{li2013lore}である．
これらの概要について以下で説明する．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 割込挿入法の処理流れ
\insertfigure[1]{sonyu}{fig1}{割込挿入法の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{description}
    \item[割込挿入法]\mbox{}\\
        割込挿入法は開発対象OSの他に，開発支援機構として，
        ハイパーバイザと開発を支援するOS(以下，開発支援OS)が走行する．
        ユーザが開発対象OSの割込を挿入したいコード位置に
        ハイパーコールを挿入することで，割込を発生させる．
        この際，割込はVirtual Machine Control Structure (以下，VMCS)と呼ばれる
        データ構造の値を書き換えることで発生させられる．
        割込挿入法の処理流れについて\figref{sonyu}に示し，以下で説明する．
        \begin{enumerate}
            \item
                ユーザが割込を挿入したい位置にハイパーコールを
                挿入する．この際，割込の種類とデータを指定する．
            \item 
                開発対象OSに挿入したハイパーコールにより，開発対象OS
                がハイパーバイザの開発支援機構へ割込発生要求を行う．
                その後，開発対象OSの処理を中断し，ハイパーバイザへ処理が
                遷移する．
            \item 
                ハイパーバイザの開発支援機構が開発支援OSの開発支援機構
                へ割込に必要なデータの生成要求を行う．
            \item 
                開発支援OSの開発支援機構が割込に必要なデータを生成する．
            \item 
                開発支援OSの開発支援機構がハイパーバイザの開発支援機構
                へデータの生成完了を通知する．
            \item 
                ハイパーバイザの開発支援機構がVMCSの値を変更する．
                これにより，処理がハイパーバイザから開発対象OSへ処理が遷移するとき
                割込が発生する．
            \item 
                開発対象OSへ処理が遷移し，割込が発生する．
        \end{enumerate}

        割込挿入法を用いた既存研究として仮想マシンモニタを用いた割込処理の
        開発手法\cite{miyahara}がある．
        これは仮想マシンモニタが開発対象OSに仮想的な割込を発生させるものである．

    \item[ロギング/リプレイ法]\mbox{}\\
        ロギング/リプレイ法は開発対象OSの他に，開発支援機構として，
        ハイパーバイザが走行する．
        この手法は開発対象OSがバグを起こすまでの流れを保存(ロギング)し，
        再現(リプレイ)することで，バグを再現し，開発を支援する．
        ロギングの処理流れを\figref{loging}に示し，以下で説明する．

        \begin{enumerate}
            \item 
                開発対象OSに割込が発生すると，
                処理を中断し，ハイパーバイザに処理が遷移する．
            \item 
                ハイパーバイザの開発支援機構が再現情報をメモリに格納する．
            \item 
                ハイパーバイザから開発対象OSへ処理が遷移し，
                開発対象OSが中断していた割込処理を再開する．
        \end{enumerate}

        リプレイの処理流れについて\figref{replay}に示し，
        以下で説明する．

        \begin{enumerate}
            \item 
                ハイパーバイザの開発支援機構がメモリから再現情報を取得する．
            \item 
                取得した再現情報より開発対象OSが割込が発生するアドレスまで
                命令を実行する．
            \item 
                ハイパーバイザの開発支援機構が再現情報の分岐回数と，現在の
                開発対象OSの分岐回数を比較する．
                比較結果により，以下の処理に分岐する．
                \begin{enumerate}
                    \item 一致した場合，(4)へ進む．
                    \item 一致しない場合，(2)へ進む．
                \end{enumerate}
            \item 
                開発対象OSへ割込が発生する．
        \end{enumerate}

        ロギング/リプレイ法を用いた既存研究としてTTVM\cite{samuel}，
        Aftersight\cite{jim}，Sesta\cite{kawasaki}，およびLoRe\cite{li2013lore}がある．
        TTVMは再現情報に加え，開発対象OS側のVMの状態を保存する．
        Aftersightはロギングとリプレイを異なる種類のハイパーバイザで行う．
        Sestaはロギングを行うOSの処理を追うようにしてリプレイを行うOSを走行させる．
        LoReはログのサイズと再現時間の削減を行っている．
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ロギングの処理流れ
\insertfigure[0.9]{loging}{fig2}{ロギングの処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% リプレイの処理流れ
\insertfigure[0.9]{replay}{fig3}{リプレイの処理流れ}{Awesome Figure 1.} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
%% 2.4節 問題点
\subsection{問題点}\label{sec:problem}
%%%%%%%%%%%%%%%%

既存手法の割込挿入法とロギング/リプレイ法のそれぞれの問題点について
以下で説明する．

\begin{description}
    \item[(割込挿入法)]任意の間隔で発生する複数割込の挿入が困難\\
        割込挿入法では割込を発生させる際，OSのコードの任意の位置にハイパーコールを
        挿入することで割込を発生させる．ハイパーコールが実行されるタイミングはOSの処理速度に
        依存する．このため，複数の割込をCPUへ発生させる間隔の調整は，
        ハイパーコールの間隔を調整することで行う．この間隔をユーザが調整するのは困難である．
        したがって，から割込挿入法では任意の間隔での割込挿入が困難である．

    \item[(ロギング/リプレイ法)]実時間を反映したロギングが困難\\
        ロギング/リプレイ手法は，ロギングにおける開発対象OS とハイパーバイザ間
        の処理の遷移や再現情報の格納による処理負荷が発生する．このため，
        実際に発生した割込間隔と再現情報の割込間隔には処理負荷分のずれが
        できる．したがって，実時間を反映したロギングが困難であり，再現する割込は
        実際に発生する割込間隔よりも長い間隔となってしまう．
\end{description}

これらの問題点から，既存手法では短い間隔で複数割込を発生させるようなストレステストや
パフォーマンスチューニングのようなテストには使用できないと考えられる．
短い割込や任意の間隔の割込を発生させるためには，開発対象OSが開発支援機構の
処理負荷の影響を受けない環境が必要である．
また，実際の割込処理の再現をするため，これらの環境は実際の割込処理と同様の挙動をする
必要がある．

%%%%%%%%%%%%%%%%
%% 3章 Mintオペレーティングシステム
\section{Mintを用いた開発支援環境}\label{chap:Mint}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsection{Mintオペレーティングシステム}\label{sec:structure_of_Mint}
%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Mintの構成
\insertfigure[0.7]{mintkousei}{fig4}{Mintの構成}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mintオペレーティングシステムは1台の計算機上で仮想化を用いずに複数のOSを動作できる方式である．
Mintでは，1台の計算機上でプロセッサ，メモリ，およびデバイスを分割し，各OSが
占有する．Mintの構成例を\figref{mintkousei}に示し，説明する．
本稿ではMintを構成するOSをOSノードと呼ぶ．
Mintでは，最初に起動するOSをOSノード0とし，起動順にOSノード1，OSノード2，
．．．とする．

\begin{enumerate}
    \item プロセッサ\\
        コア単位で分割し，各OS ノードがコアを1 つ以上占有する．
    \item メモリ\\
        空間分割し，各OS ノードが分割領域を占有する．
    \item デバイス\\
        デバイス単位で分割し，各OS ノードが指定されたデバイスを占有する．
\end{enumerate}

このようにしてMintではマルチコアプロセッサCPUのコアを分割し，複数のLinuxを同時に走行できる．
Mintを用いることで，開発対象のOSの外に開発支援OSを動作させ，開発支援OSから
開発対象OSへ割込を発生させることで開発を支援する環境を提案する．

%%%%%%%%%%%%%
\subsection{方針}\label{sec:policy}
%%%%%%%%%%%%%

\ref{sec:problem}節に示したVMを用いた割込開発支援手法の問題点を解決する手段としての
Mintを用いた開発支援環境の方針について以下に示し，説明する．
\begin{description}
    \item[(方針1)] 実際に発生する割込間隔を実現する環境の提供\\
        ストレステスト等の短い割込を連続で発生させるようなテストを実施するには，
        実際に発生する割込間隔程度の間隔で割込を発生できる環境が必要である．
        しかし，VMを用いた既存研究では\ref{sec:problem}節で述べた問題により，短い間隔の割込
        の発生が困難である．そこでMintを用いた割込処理の開発支援環境では，開発
        対象OSへ実際に発生する割込間隔程度の短い間隔で割込を発生できる環境を提供する．
    \item[(方針2)] 任意のパタンで割込を発生させる環境の提供\\
        テストによっては，短い周期や長い周期で複数の割込を発生させる必要がある．
        しかし，VMを用いた既存研究では\ref{sec:problem}節で述べた問題により，任意の間隔での
        割込発生が困難である．そこでMintを用いた割込処理の開発支援環境では，
        開発対象OSへ任意の間隔で割込を発生できる環境を提供する．
\end{description}

%%%%%%%%%%%%%
\subsection{構成と処理流れ}\label{sec:structure_and_processing_flow}
%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Mintを用いた開発支援環境の処理流れ
\insertfigure[0.9]{mintdebugnagare}{fig5}{Mintを用いた開発支援環境の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mintを用いた開発支援環境について\figref{mintdebugnagare}に示し，
説明する．
Mint上で開発支援OSをOSノード0，開発対象OSをOSノード1として動作させる．
開発支援OSはコア0を占有し，割込管理アプリケーション(以下，割込管理AP)と開発支援機構を持つ．
開発対象OSはコア1を占有する．
この構成で下記の処理を行うことにより，割込を発生させる．

\begin{enumerate}
    \item 
        開発支援OS上で動作するアプリケーションである割込管理APを用いて
        ユーザが割込情報を指定する．
    \item 
        割込管理APがシステムコールを用いて開発支援機構を呼び出す際，
        指定した割込情報を開発支援OSの開発支援機構に通知する．   
    \item 
        開発支援機構がコア0へInter-Processor Interrupt(以下，IPI)の送信要求を行う．
    \item 
        コア0がIPIの送信要求を受けると，コア1へIPIを送信する．
    \item 
        コア1がIPIを受信すると割込処理が開始する．
\end{enumerate}

%%%%%%%%%%%%%
\subsection{Linux改変による割込処理の挙動への影響}\label{sec:impact_to_linux}
%%%%%%%%%%%%%

Mintでは1台の計算機上で複数のLinuxを動作させるため，各Linuxに
改変を加えている\cite{kitagawa}．
この際の改変は各Linuxの起動時に認識するプロセッサ，メモリ，およびデバイスを調停するための
ものである．起動終了処理のみ変更を加えており，
それ以外の機能は改変前のLinuxと同様に動作する．
したがって，Mintにおける割込処理は，改変前のLinuxの割込処理と同等であるといえる．
このため，Linuxの開発に有用であると考えられる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 4章 NICドライバの割込開発環境の設計
\section{NICドライバの開発支援環境の設計}\label{chap:design_of_debugging_invironment_of_NIC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsection{目的}\label{sec:purpose}
%%%%%%%%%%%%%%%%

割込処理の1つに，デバイスドライバの割込処理がある．
NICでは頻繁に通信を行なっているため，割込処理も頻繁に行われている．
また，複雑化するデバイスドライバの開発を支援する手法が重要になっている．
デバイスドライバを開発対象とした研究としてSymDrive\cite{renzelmann2012symdrive}
がある．これはデバイスを用いずにドライバのコードを網羅的に実行することで
バグを発見し，開発を支援する．しかし，SymDriveでは任意に割込を発生できないため，
ストレステストやパフォーマンスチューニングのようなテストには
使用できない．
また，NICの高速化によりNICドライバやプロトコル処理の高速化させる
必要があり\cite{yildirim2012end}，これらのテストが重要になっている．
そこで，NICドライバを対象としたMintを用いた割込開発支援環境を構築し，
割込処理を再現できる環境を実現する．
これにより，Mintにおける割込処理の開発支援環境で，割込処理を再現する．

%%%%%%%%%%%%%%%%
\subsection{設計方針}\label{sec:policy_of_design}
%%%%%%%%%%%%%%%%

Mintを用いたNICドライバの割込開発支援環境の設計方針に
ついて以下に示し，説明する．

\begin{description}
    \item[(設計方針1)] 任意の間隔と回数の割込発生\\
        テストによっては任意の間隔の割込を任意の回数分発生させる必要がある．
        このため，本開発支援環境では発生させる割込の間隔と回数を
        ユーザが指定可能な環境を提供する．
    \item[(設計方針2)] NICの動作を開発支援OSが再現\\
        NICドライバの割込処理の開発を対象とするため，
        ハードウェア(NIC)の動作は考慮しない．
        したがって，NICを用いずに割込開発支援環境を構築する．
        このため，開発支援OSがNICを再現することとする．
        これにより，NICを用いずにNICドライバの割込開発支援環境を構築する．
    \item[(設計方針3)] 共有メモリを用いたパケットの受け渡し\\
        NICのパケット受信割込処理を再現するため，開発対象OSで
        パケットを受け取る必要がある．
        開発対象OSがパケットを受け取るには，
        入出力デバイスかメモリを用いる．
        本研究ではテスト対象のデバイスの動作を考慮しないため，入出力デバイスは用いない．
        そこで，開発支援OSと開発対象OS間の共有メモリを用いる．
        共有メモリ上にNICの受信バッファを
        配置することにより，開発支援OSから開発対象OSの
        NICドライバへパケットを受け渡す．
\end{description}

%%%%%%%%%%%%%%%%
\subsection{課題}\label{sec:challenge}
%%%%%%%%%%%%%%%%

設計にあたって，\ref{sec:policy_of_design}節に挙げた各設計についての課題を以下に示し，説明する．

\begin{itemize}
    \item[(設計方針1)]\mbox{}
        \begin{description}
            \item[(課題1)] 割込間隔，回数の調整\\
                任意の間隔と回数で割込を発生させるため，割込の間隔を調整し連続で
                割込を発生させる必要がある．これらの情報をユーザが指定可能にする必要がある．
        \end{description}
    \item[(設計方針2)]\mbox{}
        \begin{description}
            \item[(課題2)] パケットの作成，格納\\
                NICドライバのパケット受信処理を再現するため，処理させるパケットを
                作成し，受信バッファに格納する必要がある．
            \item[(課題3)] NICの状態の更新\\
                NICがパケットを受信バッファに格納する際，NICは受信バッファ状態を書き換え，
                受信済み状態にする．受信バッファ状態とは受信バッファがパケットを受信しているか否かの
                状態である．この状態は受信ディスクリプタという受信バッファを管理する構造に含まれている．
                本環境ではNICハードウェアを用いないためNICを用いずに受信バッファ状態を書き換える必要がある．
            \item[(課題4)] 割込処理の発生\\
                本環境ではNICハードウェアを用いないため，
                NICの機能であるOSへ割込を発生させる機能を再現する必要がある．
                また，発生させた割込にNICドライバの割込ハンドラが反応可能にする必要がある．
        \end{description}
    \item[(設計方針3)]\mbox{}
        \begin{description}
            \item[(課題5)] 受信バッファの作成\\
                開発支援OSが共有メモリにパケットを配置し，
                開発対象OSが共有メモリからパケットを取得するため，共有メモリに
                NICの受信バッファを作成する必要がある．
        \end{description}
\end{itemize}

%%%%%%%%%%%%%%%%
\subsection{対処}\label{sec:deal}
%%%%%%%%%%%%%%%%

課題への対処を以下に示し，説明する．
また，各対処の通番は課題と対応している．

\begin{description}
    \item[(対処1)] 割込管理APによる割込情報の指定\\
        割込間隔と回数をユーザが指定できるようにするため，
        開発支援OS上にこれらの情報が指定できる割込管理APを
        実装する．指定した間隔と回数で割込を発生させる
        システムコールを発行する．
    \item[(対処2)] パケットの作成，格納\\
        割込管理APでパケットを作成し，作成したパケットを
        システムコールにより開発支援機構に渡す．
        その後，開発支援機構が受信バッファにパケットを格納する．
    \item[(対処3)] NICの状態の更新\\
        受信バッファ状態を開発支援OSが書き換え可能にするため，
        受信ディスクリプタを共有メモリに配置し，開発支援OSと開発対象OS
        の両OSで参照可能にする．
    \item[(対処4)] 割込契機としてIPIを使用\\
        割込の契機としてコア間割込であるIPIを用いる．開発支援OSが占有する
        コアから開発対象OSが占有するコアへIPIを送信することで割込処理を発生させる．
        また，IPIによりNICドライバの割込ハンドラが反応するように改変を加える．
        この際の改変は割込ハンドラが動作するまでの流れを変更するものであり，
        ハンドラの処理自体に影響はない．
    \item[(対処5)] 共有メモリへ受信バッファの作成\\
        共有メモリを用いて開発支援OSと開発対象OSのNICドライバ
        間でパケットを受け渡すため，NICの受信バッファを共有メモリに作成する
        必要がある．このため，NICドライバの初期化処理内で，受信バッファの
        アドレスを変更し，共有メモリのアドレスにする．
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 5章 実装
\section{実装}\label{chap:implemantation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

4章の対処を元に，開発支援環境を実装した．
実装した開発支援環境の処理流れを\figref{nicmintnagare}に示し，以下で説明する．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NICドライバの開発支援環境の処理流れ
\insertfigure[1.0]{nicmintnagare}{fig8}{NICドライバの開発支援環境の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
    \item
        ユーザが割込管理APを用いて割込情報を指定する．
    \item 
        割込管理APがパケットを作成する．
        本実装では，作成するパケットはUDPパケットを含んだEthernetFrameである．
    \item 
        割込管理APが開発支援OSの開発支援機構を
        システムコールを用いて呼び出す．
        この際(1)で指定した割込情報と(2)で作成したパケットを通知する．
    \item 
        開発支援機構が共有メモリの受信バッファへパケットを格納する．
    \item 
        開発支援機構が共有メモリの受信ディスクリプタの受信バッファ状態
        を更新する．
    \item
        開発支援機構がコア0へIPI送信要求を行う．
    \item
        コア0がコア1へIPIを送信する．
    \item 
        コア1がIPIを受信すると，
        開発対象OSの割込ハンドラが動作する．
    \item 
        NICドライバが共有メモリの受信ディスクリプタ中の
        受信バッファ状態を確認する．
    \item 
        NICドライバが共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する．
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6章 評価 
\section{評価}\label{chap:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsection{評価項目}\label{sec:item-of-evaluation}
%%%%%%%%%%%%%%%%

実装した開発支援環境を以下の項目で評価する．
\begin{description}
    \item[(評価 1)]実現可能な割込間隔の評価
    \item[(評価 2)]割込間隔の精度の評価
    \item[(評価 3)]実テストへの応用評価
\end{description}

(評価 1)では，本環境を用いることで，どの程度の短い間隔で割込を発生できるかを測定し，
実現可能な割込間隔について評価する．
送信処理にはパケットをメモリに複写する処理が含まれる．
このため，パケットサイズ毎に送信処理時間が長大し，実現できる送信間隔も長大すると
考えられる．

(評価 2)では，開発支援OSで割込間隔を指定して連続で割込を発生させた際，
開発対象OSにおいて，どの程度の精度で指定した割込間隔を実現できているかを評価する．

(評価 3)では本環境を用いてNICドライバの性能測定を行う．
本環境を用いて，送信間隔を指定して連続でパケットを送信した際，その間隔ならば，
どの程度の確率でパケットを受信できるかを測定する．
また，この測定結果からどの程度の通信量を実現できているかを算出する．

%%%%%%%%%%%%%%%%
\subsection{実現可能な送信間隔の評価}\label{sec:interval}
%%%%%%%%%%%%%%%%

本開発支援環境がどの程度の短い間隔で割込を発生可能かを評価する．
割込はIPIの送信によって発生するため，IPIの送信間隔は割込の発生間隔といえる．
IPIの送信はパケットの送信処理の最後に行われるため，1回の送信処理時間が割込発生間隔の最小値である．
ここで，パケットの送信処理とは\figref{nicmintnagare}の(4)〜(7)である．
このため，送信処理にかかる時間を測定し，実現可能な割込間隔の最小値を求める．

送信処理にはメモリ複写処理が含まれており，パケットのサイズによって送信処理が変わると考えられる．
したがって，3つのパケットサイズにおける送信処理時間を評価する．
具体的には，各パケットサイズで1000回送信処理を測定し，
平均時間を取ることで，処理時間とした．
測定に用いるパケットサイズは，以下の3つである．
\begin{enumerate}
    \item 1.5KB(MTUのサイズ)
    \item 8KB(受信バッファの半分のサイズ)
    \item 16KB(受信バッファのサイズ)
\end{enumerate}

結果を\tabref{tx-time}に示し，以下で説明する．
パケットのサイズの増加にともなって，送信処理時間が長大していることが分かる．
これは，送信処理中にメモリ複写処理が含まれるためである．
\tabref{tx-time}の値は本開発支援環境を用いて，連続でパケットを送信しようとした際に実現できる
最短の時間であるといえる．
したがって，\tabref{tx-time}に示した時間以上の送信間隔を実現できる．

%\insertfigure[0.8]{fig:tx-time}{fig31}{パケットサイズと送信処理時間の関係}{ipi route}

\begin{table}[h]
    \caption{各パケットサイズにおける送信処理時間}
    \label{tx-time}
    \begin{center}
        \begin{tabular}{D..{-1}|D{.}{.}{-1}}   \hline \hline 
            \multicolumn{1}{c|}{パケットサイズ (KB)}&
            \multicolumn{1}{c}{処理時間 (μs)}\\ \hline
            1.5                      & 0.205            \\
            8                        & 1.462            \\
            16                       & 3.664            \\ \hline
        \end{tabular}
    \end{center}
\end{table}

%%%%%%%%%%%%%%%%
\subsection{割込間隔の精度の評価}\label{sec:interval}
%%%%%%%%%%%%%%%%

\insertfigure[0.8]{fig:mint-interval}{fig35}{38μsの間隔を指定した際の割込発生間隔のずれ}{ipi route}

本環境を用いて連続で割込を発生させた際，開発対象OSでどの程度の精度で指定した割込間隔を実現できているかを
評価する．

評価にあたり実計算機2台をLANケーブルで接続し，NICを用いて連続でパケットを送信した際，約\mbox{38μs}の間隔で割込が
発生していることを確認した．この際，常に割込間隔は安定せず，試行毎に\mbox{38±2μs}ほどぶれていた．
また，稀に大きな外れ値があり，一定の間隔では割込が発生していないことを確認した．

そこで，本環境を用いて割込間隔を\mbox{38μs}に指定し，1000回連続で開発対象OSに割込を発生させた際，
割込ハンドラが動作する間隔を測定し，それぞれの間隔が\mbox{38μs}とどれだけ差があるかを測定し，精度について評価する．

結果を\figref{fig:mint-interval}に示し，以下で説明する．
ほとんどの場合，指定した間隔である\mbox{38μs}と差がなく，指定した間隔で割込を発生できていることが分かる．
1000回の試行で\mbox{38μs}から外れたものは4回であり，一番大きな外れ値が\mbox{+2μs}である．
\mbox{38μs}から見ると，全てのずれは±6.25\%以内に収まっている．

%%%%%%%%%%%%%%%%
\subsection{実テストへの応用評価}\label{sec:interval}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsubsection{NICドライバの性能測定}\label{sec:interval}
%%%%%%%%%%%%%%%%

本開発環境を用いて実際にNICドライバのテストを行う．
以下の2つの項目で性能評価テストを行う．
\begin{enumerate}
    \item 各パケットサイズにおけるNICドライバで処理可能な割込間隔の測定
    \item 各パケットサイズにおけるNICドライバで実現可能な通信速度の測定
\end{enumerate}
これらの項目を測定することにより，NICドライバの処理性能を調査する．
これにより，本環境が高速なNICを擬似することによりNICハードウェアを用いずに
開発対象ドライバの処理性能をテストできることを示す．
本環境を用いてテストを行うことにより，開発対象ドライバがどの程度高速なNICに
対応できるかが分かる．

%%%%%%%%%%%%%%%%
\subsubsection{NICドライバで処理可能な割込間隔の測定}\label{sec:mint-interval}
%%%%%%%%%%%%%%%%
\insertfigure[0.9]{fig:driver}{fig32}{送信処理動作間隔とNICドライバにおけるパケット受信成功率の関係}{ipi route}
指定した間隔で送信処理を5000回動作させ，NICドライバでのパケット受信成功率を求めることを1サイクルとし，
割込間隔を増加させながら複数サイクル行う．これにより，割込間隔がどの程度ならば受信成功率が
100\%になるかを測定する．受信処理にはメモリ複写処理が含まれるため，パケットサイズの増加にともなって100\%になる
間隔が長大化すると考えられる．このため，この試行を複数のパケットサイズで行う．
測定に使用するパケットサイズは\ref{sec:interval}節と同じ以下の3つのものを用いる．
\begin{enumerate}
    \item 1.5KB(MTUのサイズ)
    \item 8KB(受信バッファの半分のサイズ)
    \item 16KB(受信バッファのサイズ)
\end{enumerate}

結果を\figref{fig:driver}に示し，以下で説明する．
なお，図中の丸印は各パケットサイズで実現可能な送信間隔の最小値(\tabref{tx-time})を示しており，
これ以下の間隔は実現できないためこれ以上の間隔の結果を示している．
結果から，送信間隔の増加にともなって，受信成功率が1次関数的に増加していることが分かる．
また，パケットのサイズの増加にともなって，受信成功率が100\%になるまでの間隔が長大化している．
これは，パケット受信割込処理中にメモリの複写が行われるためだと考えられる．

すべてのパケットを受信可能な間隔が送信処理の最小値に比べて大きいのは，受信処理には
ソケットバッファをドライバよりも上位のレイヤに送信する処理が含まれているためである．

%%%%%%%%%%%%%%%%
\subsubsection{NICドライバで実現可能な通信速度}\label{sec:interval}
%%%%%%%%%%%%%%%%

連続でパケットを送信した際，各パケットサイズ毎にNICドライバで実現できる
最大の通信速度を算出した．具体的には，\ref{sec:mint-interval}項と同じ方法の測定において
初めてパケット受信成功率が100\%となった際の送信処理5000回にかかった時間とパケットのサイズから各パケットの通信量を算出した．
また，同様にNICハードウェアを用いてNICドライバで処理できる最大の通信量を測定した．
具体的には，2台の計算機をLANケーブルで接続し，一方の計算機から他方の計算機へパケットを連続で
送信した際の通信速度を測定した．
測定において，どちらの場合もパケットサイズはMTUである1.5KBとした．これらを比較し，評価する．

結果を\tabref{throughput-nic}に示し，以下で説明する．
\tabref{throughput-nic}から実NICを大きく超える通信速度を実現できていることがわかる．
また，最高で30Gbpsを実現できており，実NICより高速なNICをエミュレートできていることが分かる．

このことから，新規NICドライバ開発において開発対象ドライバを高速なNICに対応させる際に本環境を用いることで，
NICを用いずに高速なNICを擬似し，開発対象ドライバの処理性能を測定するといった用途が考えられる．

メモリのみを用いて通信を行なっているため，このような膨大な通信量を実現できる．
測定を行った計算機のメモリ帯域幅は約130Gbpsであり，受信処理にはメモリ複写以外に長い時間を費やす処理が
含まれているため，これは妥当な結果であると言える．

\begin{table}[h]
    \caption{各パケットサイズにおける実現可能な通信量}
    \label{throughput-nic}
    \begin{center}
        \begin{tabular}{D..{-1}|D{.}{.}{-1}}   \hline \hline 
            \multicolumn{1}{c|}{パケットサイズ (KB)}&
            \multicolumn{1}{c}{通信量 (Gbps)}\\ \hline
            1.5 \texttt{(実NIC)}               & 0.92           \\
            1.5                      & 6.3            \\
            8                        & 22.7           \\
            16                       & 30.6           \\ \hline
        \end{tabular}
    \end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 7章 おわりに
\section{おわりに}\label{chap:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本稿ではMintを用いたNICドライバの割込開発手法について述べた．
まず既存研究であるVMを用いたOSの割込開発手法と問題点について述べた．
次にMintとMintを用いた割込開発手法について述べた．
次に，Mintを用いたNICドライバの割込開発環境の方針，課題，
および対処について述べた．
そして，Mintを用いた割込開発環境の実装について述べた．
最後にMintを用いた割込開発環境の評価について述べた．

Mintを用いたNICドライバの割込開発環境では，任意の間隔で割込を発生させられる環境と
NICを用いずパケットを授受する環境を提供する．
設計の課題として，割込間隔と回数の調整，パケットの作成と格納，NICの状態の
更新，割込の発生作成，および受信バッファの作成を示した．
これらの対処として，割込管理APの作成，開発支援機構の作成，IPIの送信，および
NICドライバの改変を示した．

本研究ではNICのパケット受信処理に対するNICドライバの割込処理を開発対象とした．
これを実現する機能として，割込管理AP，パケットの作成，受信バッファへのパケットの格納，
受信バッファ状態の更新，IPIの送信，割込ハンドラ，および受信バッファの作成について示した．
これらの機能の内，割込管理APは開発支援OS上で動作するAPとして実装し，割込情報の指定とパケットの
作成を行い，開発支援機構に通知することを示した．パケットの作成，受信バッファへの
パケットの格納，NICの状態の更新，およびIPIの送信については開発支援機構の機能として
動作するもので，システムコールとして実装することを示した．
割込ハンドラの動作，および受信バッファの作成についてはNICドライバを改変し，実現することを示した．

実装した開発支援環境を用いて，連続で割込を発生させた際，指定した間隔を守って，割込を
発生させられることを示した．
また，本環境を用いて実際にNICドライバのテストを行った際，NICドライバがどの程度の
通信速度を実現可能かを調査可能であることを示した．
本環境を用いることでNICハードウェアを用いずにNICドライバの処理性能を調査するといった
使用法が考えられる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 参考文献
\bibliographystyle{ipsjunsrt} % 情報処理学会形式(新)
\bibliography{mybibdata}

\end{document}
