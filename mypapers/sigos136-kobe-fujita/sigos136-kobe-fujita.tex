\documentclass[submit,techreq,noauthor,dvipdfmx]{ipsj}

\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{url}    % bibtex で url を使う
\urlstyle{same}     % フォントが変わる問題をなくす

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% sty/ にある研究室独自のスタイルファイル

\usepackage{jtygm}  % フォントに関する余計な警告を消す
\usepackage{nutils} % insertfigure, figef, tabref マクロ

\def\figdir{./figs} % 図のディレクトリ
\def\figext{pdf}    % 図のファイルの拡張子

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 文字に関するマクロ

\def\DesktopBookmark{\mbox{Desktop} \mbox{Bookmark}}
\def\DTB{\mbox{DTB}}
\def\WorkState{\mbox{Time} \mbox{Entry}}
\def\Task{\mbox{Task}}
\def\Recurrence{\mbox{Recurrence}}
\def\Mission{\mbox{Mission}}
\def\Job{\mbox{Job}}
\def\Duration{\mbox{Duration}}
\def\TimeEntry{\mbox{Time} \mbox{Entry}}
\def\UnifiedHistory{\mbox{Unified} \mbox{History}}
\newcommand{\Info}[1]{\mbox{（情報#1）}}
\newcommand{\Source}[1]{\mbox{（情報源#1）}}
\newcommand{\Step}[2]{\mbox{（手順#1-#2）}}
\newcommand{\Number}[1]{\mbox{（通番#1）}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}

\setcounter{巻数}{1}%vol53=2012
\setcounter{号数}{1}
\setcounter{page}{1}

\begin{document}

\title{Mintオペレーティングシステムを用いた\\NICドライバの割り込みデバッグ手法の実現}

\affiliate{OU}{岡山大学大学院自然科学研究科\\
Graduate School of Natural Science and Technology, Okayama University}

\author{藤田 将輝}{Masaki Fujita}{OU}
\author{乃村 能成}{Yoshinari Nomura}{OU}
\author{谷口 秀夫}{Hideo Taniguchi}{OU}

\begin{abstract}

    近年，Operating System(以下，OS)の多機能化にともなって，
    OSのデバッグが重要となり，活発に研究されている．
    特に，非同期的な処理は，常に同じタイミングで発生しないため，再現が困難である．
    この非同期的な処理の1つに割り込み処理がある．
    割り込み処理のデバッグを支援する方法として，仮想計算機(以下，VM)を用いたものがある．
    VMを用いることの利点は2つある．1つは1台の計算機上でデバッグを支援する
    機構(以下，デバッグ支援機構)とデバッグ対象のOS(以下，デバッグ対象OS)を
    動作できることである．
    これにより，計算機を2台用意するためのコストを削減できる．
    もう1つは，デバッグ支援機構をデバッグ対象OSの外部に実装できる点である．
    これにより，デバッグ支援機構がデバッグ対象OSのバグの影響を受けない．

\end{abstract}

\begin{jkeyword}
    仮想化，割り込み，デバッグ
\end{jkeyword}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 1章 はじめに
\section{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

近年，Operating System(以下，OS)の多機能化にともなって，
OSのデバッグが重要となり，活発に研究されている．
特に，非同期的な処理は，常に同じタイミングで発生しないため，再現が困難である．
この非同期的な処理の1つに割り込み処理がある．
割り込み処理のデバッグを支援する方法として，仮想計算機(以下，VM)を用いたものがある．
VMを用いることの利点は2つある．1つは1台の計算機上でデバッグを支援する
機構(以下，デバッグ支援機構)とデバッグ対象のOS(以下，デバッグ対象OS)を
動作できることである．
これにより，計算機を2台用意するためのコストを削減できる．
もう1つは，デバッグ支援機構をデバッグ対象OSの外部に実装できる点である．
これにより，デバッグ支援機構がデバッグ対象OSのバグの影響を受けない．
デバッグ支援機構がデバッグ対象OSへ割り込みを挿入させたり，
デバッグ支援機構がデバッグ対象OSの動作を再現したりすることで，
バグを再現し，デバッグを支援する．
しかし，VMを用いる場合，VMとハイパーバイザ間の
処理の遷移に伴う処理負荷が存在する．
このため，VMを用いたデバッグ支援環境では一定間隔で発生する
割り込みや，短い間隔で発生するバグのように，処理負荷が影響する
割り込み処理のデバッグが困難である．

そこで，Multiple Independent operating systems with New Technology(以下，Mint)\cite{senzaki}
を用いたデバッグ手法が提案されている．
Mintは仮想化を用いずに複数のLinuxを動作できる．
Mintを用いてデバッグ支援環境を構築すると，
ハイパーバイザが存在しないため，処理の遷移に伴う処理負荷も
存在しなくなる．
これにより，一定間隔で発生する割り込みや短い間隔で発生する
割り込みの再現が可能になる．

本研究では，提案手法を用いて非同期的な割り込みが頻繁に発生するNICドライバを対象とした
デバッグ支援環境の実装について述べる．
これにより，Mintにおける割り込み処理のデバッグ支援環境で，割り込み処理が
再現できることを示す．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2章 関連研究
\section{関連研究}\label{chap:related_reserch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
%% 2.1節 VMを用いたデバッグ支援機構
\subsection{VMを用いたデバッグ支援機構}\label{sec:debugging_support_mechanism_with_VM}
%%%%%%%%%%%%%%%%

OSの割り込みのデバッグを支援する環境の既存研究としてVMを用いたものがある．
VMを用いた割り込みデバッグ支援環境は大きく分けて2つある．
割り込み挿入法\cite{miyahara}とロギング/リプレイ手法\cite{samuel}\cite{jim}\cite{kawasaki}である．
これらの概要について以下で説明する．

\begin{description}
    \item[割り込み挿入法]\mbox{}\\
        割り込み挿入法はデバッグ対象OSの他に，デバッグ支援機構として，
        ハイパーバイザとデバッグを支援するOS(以下，デバッグ支援OS)が走行する．
        ユーザがデバッグ対象OSの割り込みを挿入したいコード位置に
        ハイパーコールを挿入する．
        デバッグ対象OSの走行時に，ハイパーコールを挿入した位置で
        処理がハイパーバイザに遷移する．
        そして，デバッグ支援OSで割り込みに必要なデータを用意した後，
        デバッグ対象OSに割り込みを発生させ，バグを再現する．
        これにより，デバッグを支援する．
        割り込み挿入法を用いた既存研究として仮想マシンモニタを用いた割り込み処理の
        デバッグ手法\cite{miyahara}がある．
        これは仮想マシンモニタがデバッグ対象OSに仮想的な割り込みを発生させるものである．
    \item[ロギング/リプレイ手法]\mbox{}\\
        ロギング/リプレイ手法はデバッグ対象OSの他に，デバッグ支援機構として，
        ハイパーバイザが走行する．
        この手法はデバッグ対象OSがバグを起こすまでの流れを保存(ロギング)し，
        再現(リプレイ)することで，デバッグを支援する．
        また，動作の流れを再現するための情報(以下，再現情報)として，以下の2つがある．
        \begin{enumerate}
            \item 割り込みの種類，割り込み発生アドレス，および分岐命令を経由した回数
            \item キーコードや，パケットなどのような割り込み処理で扱うデータ
        \end{enumerate}
        ロギング/リプレイ手法を用いた既存研究としてTTVM\cite{samuel}，
        Aftersight\cite{jim}およびSesta\cite{kawasaki}がある．
        TTVMは再現情報に加え，デバッグ対象OS側のVMの状態を保存する．
        Aftersightはロギングとリプレイを異なる種類のハイパーバイザで行う．
        Sestaはロギングを行うOSの処理を追うようにしてリプレイを行うOSを走行させる．
\end{description}


%%%%%%%%%%%%%%%%
%% 2.2節 割り込み挿入法の処理流れ
\subsection{割り込み挿入法の処理流れ}\label{sec:processing_flow_interrupt_inserting_method}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 割り込み挿入法の処理流れ
\insertfigure[1]{sonyu}{fig1}{割り込み挿入法の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

割り込み挿入法における割り込みは，ユーザが割り込みを発生させたいコード位置に
ハイパーコールを挿入することで発生させる．割り込みは挿入したコード位置で発生する．
この際，割り込みはVirtual Machine Control Structure(以下，VMCS)
と呼ばれるデータ構造の値を書き換えることで発生させられる．
デバッグ対象OSとデバッグ支援OSはハイパーバイザ内のデバッグ支援機構
でデータの授受をする．
割り込み挿入法の処理流れについて図\ref{sonyu}に示し，
以下で説明する．
\begin{enumerate}
    \item
        ユーザが割り込みを挿入したい位置にハイパーコールを
        挿入する．この際，割り込みの種類とデータを指定する．
    \item 
        デバッグ対象OSに挿入したハイパーコールにより，デバッグ対象OS
        がハイパーバイザのデバッグ支援機構へ割り込み発生要求を行う．
        その後，デバッグ対象OSの処理を中断し，ハイパーバイザへ処理が
        遷移する．
    \item 
        ハイパーバイザのデバッグ支援機構がデバッグ支援OSのデバッグ支援機構
        へ割り込みに必要なデータの生成要求を行う．
    \item 
        デバッグ支援OSのデバッグ支援機構が割り込みに必要なデータを生成する．
    \item 
        デバッグ支援OSのデバッグ支援機構がハイパーバイザのデバッグ支援機構
        へデータの生成完了を通知する．
    \item 
        ハイパーバイザのデバッグ支援機構がVMCSの値を変更する．
        これにより，処理がハイパーバイザからデバッグ対象OSへ処理が遷移するとき
        割り込みが発生する．
    \item 
        デバッグ対象OSへ処理が遷移し，割り込みが発生する．
\end{enumerate}

このように，ハイパーバイザへの処理の遷移のため，
処理負荷が発生しており，短い間隔や一定間隔の割り込み挿入が困難である．

%%%%%%%%%%%%%%%%
%% 2.3節 ロギング/リプレイ手法の処理流れ
\subsection{ロギング/リプレイ手法の処理流れ}\label{sec:processing_flow_rogging/replay_method}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
%% 2.3.1項 ロギングの処理流れ
\subsubsection{ロギングの処理流れ}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ロギングの処理流れ
\insertfigure[0.9]{loging}{fig2}{ロギングの処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ロギングの処理流れについて図\ref{loging}に示し，
以下で説明する．

\begin{enumerate}
    \item 
        デバッグ対象OSに割り込みが発生すると，
        処理を中断し，ハイパーバイザに処理が遷移する．
    \item 
        ハイパーバイザのデバッグ支援機構が再現情報をメモリに格納する．
    \item 
        ハイパーバイザからデバッグ対象OSへ処理が遷移し，
        デバッグ対象OSが中断していた割り込み処理を再開する．
\end{enumerate}

%%%%%%%%%%%%%%%%
%% 2.3.2項 リプレイの処理流れ
\subsubsection{リプレイの処理流れ}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% リプレイの処理流れ
\insertfigure[0.9]{replay}{fig3}{リプレイの処理流れ}{Awesome Figure 1.} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

リプレイの処理流れについて図\ref{replay}に示し，
以下で説明する．
\begin{enumerate}
    \item 
        ハイパーバイザのデバッグ支援機構がメモリから再現情報を取得する．
    \item 
        取得した再現情報よりデバッグ対象OSが割り込みが発生するアドレスまで
        命令を実行する．
    \item 
        ハイパーバイザのデバッグ支援機構が再現情報の分岐回数と，現在の
        デバッグ対象OSの分岐回数を比較する．
        比較結果により，以下の処理に分岐する．
        \begin{enumerate}
            \item 一致した場合，(4)へ進む．
            \item 一致しない場合，(2)へ進む．
        \end{enumerate}
    \item 
        デバッグ対象OSへ割り込みが発生する．
\end{enumerate}

このように，割り込みの発生タイミングを調整しようとした場合，
ユーザが再現情報を指定する必要があり，任意のタイミングの割り込み発生が困難である．
また，ロギング時にハイパーバイザへ処理が遷移するため，
この負荷により，ロギング中に実計算機上で発生する間隔での割り込みは発生しないと
考えられる．したがって，実計算機上で発生する間隔での割り込みの
再現情報が得られず，再現が困難である．

%%%%%%%%%%%%%%%%
%% 2.4節 問題点
\subsection{問題点}\label{sec:problem}
%%%%%%%%%%%%%%%%

割り込み挿入法の問題点について以下で説明する．

\begin{description}
    \item[(問題点1)]実計算機上で発生する間隔での複数割り込みの発生が困難\\
        割り込み挿入法では割り込みを発生させる際，OSのコードの任意の位置にハイパーコールを
        挿入することで割り込みを発生させる．ハイパーコールが実行されるタイミングはOSの処理速度に
        依存する．このため，複数の割り込みをCPUへ発生させる間隔の調整は，
        ハイパーコールの間隔を調整することで行う．
        ユーザがハイパーコールの間隔を調整することでCPUへ発生する間隔を
        調整することは非常に困難である．
        つまり，実計算機上で発生する間隔での複数の割り込み(以下，実割り込み)
        を発生させることが困難である．
\end{description}

また，ロギング/リプレイ手法の問題点について以下で説明する．

\begin{description}
    \item[(問題点2)]任意のタイミングでの割り込み発生が困難\\
        ロギング/リプレイ手法は，ロギング時に発生した割り込みに対する処理をリプレイ時
        に確認できる．しかし，任意のタイミングで割り込みを発生させるためには，再現情
        報として割り込みを発生させるアドレスと分岐回数をユーザが用意しなければな
        らない．これらの指定が困難であるため，任意のタイミングで割り込みを発生させる
        ことが困難である．
    \item[(問題点3)]実割り込みの発生が困難\\
        ロギング/リプレイ手法は，ロギングにおけるデバッグ対象OS とハイパーバイザ間
        の処理の遷移や再現情報の格納による処理負荷が発生する．このため，実割り込みがロ
        ギング中に発生しないと考えられる．ロギング中に実割り込みが発生しない場合，実
        割り込みを再現するための再現情報を保存できない．このため，実割り込みの発生が
        困難である．
\end{description}

これらの問題点から，割り込み処理のデバッグには，デバッグ対象OSがデバッグ支援機構の
処理負荷の影響を受けない環境と任意のタイミングで割り込みを発生できる環境が必要である．
また，実際の割り込み処理の再現をするため，これらの環境は実際の割り込み処理と同様の挙動をする
必要がある．

%%%%%%%%%%%%%%%%
%% 3章 Mintオペレーティングシステム
\section{Mintオペレーティングシステム}\label{chap:Mint}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%
%% 3.1節 Mintの設計方針
\subsection{Mintの設計方針}\label{sec:design_policy_of_Mint}
%%%%%%%%%%%%%

Mintとは1台の計算機上で仮想化を用いずに計算機資源を論理分割することによって
複数のLinuxを動作させる方式である．
Mintの設計方針として以下の2つが挙げられる．

\begin{enumerate}
    \item 全てのLinuxが相互に処理負荷の影響を抑制
    \item 全てのLinuxが入出力性能を十分に利用可能
\end{enumerate}

%%%%%%%%%%%%%
\subsection{Mintの構成}\label{sec:structure_of_Mint}
%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Mintの構成
\insertfigure[0.7]{mintkousei}{fig4}{Mintの構成}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mintでは，1台の計算機上でプロセッサ，メモリ，およびデバイスを分割し，各OSが
占有する．Mintの構成例を図\ref{mintkousei}に示し，説明する．
本稿ではMintを構成するOSをOSノードと呼ぶ．
Mintでは，最初に起動するOSをOSノード0とし，起動順にOSノード1，OSノード2，
．．．とする．

\begin{enumerate}
    \item プロセッサ\\
        コア単位で分割し，各OS ノードがコアを1 つ以上占有する．
    \item メモリ\\
        空間分割し，各OS ノードが分割領域を占有する．
    \item デバイス\\
        デバイス単位で分割し，各OS ノードが指定されたデバイスを占有する．
\end{enumerate}

%%%%%%%%%%%%%
%% 3.2節 Mintを用いたデバッグ支援環境
\subsection{Mintを用いたデバッグ支援環境}\label{sec:debugging_support_mechanism_with_Mint}
%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsubsection{方針}\label{sec:policy}
%%%%%%%%%%%%%

\ref{sec:problem}節に示したVMを用いた割り込みデバッグ手法の問題点を解決する手段としての
Mintを用いたデバッグ支援環境の方針について以下に示し，説明する．
\begin{description}
    \item[(方針1)] 実割り込みを発生させる環境の提供\\
        割り込みの発生間隔に依存するバグを確認するには，実割り込みを発生させる必要がある．
        しかし，VMを用いた既存研究では\ref{sec:problem}節で述べた問題により，実割り込み
        の発生が困難である．そこでMintを用いた割り込み処理のデバッグ支援環境では，デバッグ
        対象OSへ実割り込みを発生させる環境を提供する．
    \item[(方針2)] 任意のタイミングで割り込みを発生させる環境の提供\\
        デバッグの際，デバッグ対象処理のバグの有無やバグの発生箇所を確認するために，
        デバッグ対象の処理を繰り返し実行する．しかし，割り込み処理は非同期な処理であるため
        繰り返し実行することが困難である．そこでMintを用いた割り込み処理のデバッグ支援環境
        では，任意のタイミングで割り込みを発生できる環境を提供する．
\end{description}

%%%%%%%%%%%%%
\subsubsection{構成と処理流れ}\label{sec:structure_and_processing_flow}
%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Mintを用いたデバッグ支援環境の処理流れ
\insertfigure[0.9]{mintdebugnagare}{fig5}{Mintを用いたデバッグ支援環境の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mintを用いたデバッグ支援環境について図\ref{mintdebugnagare}に示し，
説明する．
Mint上でデバッグ支援OSをOSノード0，デバッグ対象OSをOSノード1として動作させる．
デバッグ支援OSはコア0を占有し，割り込みジェネレータとデバッグ支援機構を持つ．
デバッグ対象OSはコア1を占有する．
この構成で下記の処理を行うことにより，実割り込みを発生させる．

\begin{enumerate}
    \item 
        デバッグ支援OS上で動作するアプリケーション(以下，AP)である割り込みジェネレータを用いて
        ユーザが割り込み情報を指定する．
    \item 
        割り込みジェネレータがシステムコールを用いてデバッグ支援機構を呼び出す際，
        指定した割り込み情報をデバッグ支援OSのデバッグ支援環境に通知する．   
    \item 
        デバッグ支援機構がコア0へInter-Processor Interrupt(以下，IPI)の送信要求を行う．
    \item 
        コア0がIPIの送信要求を受けると，コア1へIPIを送信する．
    \item 
        コア1がIPIを受信すると割り込み処理が開始する．
\end{enumerate}

%%%%%%%%%%%%%
\subsection{Linux改変による割り込み処理の挙動への影響}\label{sec:impact_to_linux}
%%%%%%%%%%%%%

Mintでは1台の計算機上で複数のLinuxを動作させるため，各Linuxに
改変を加えている\cite{kitagawa}．
この際の改変は各Linuxの起動時に認識するプロセッサ，メモリ，およびデバイスを調停するための
ものである．起動終了処理のみ変更を加えており，
それ以外の機能は改変前のLinuxと同様に動作する．
したがって，Mintにおける割り込み処理は，改変前のLinuxの割り込み処理と同等であるといえる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 4章 NICドライバの割り込みデバッグ環境の設計
\section{NICドライバの割り込みデバッグ環境の設計}\label{chap:design_of_debugging_invironment_of_NIC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsection{目的}\label{sec:purpose}
%%%%%%%%%%%%%%%%

割り込み処理の1つに，デバイスドライバの割り込み処理がある．
デバイスドライバの割り込み処理は，デバイスがOSへ非同期的に発生させる割り込みにより
実行される．
NICでは頻繁に通信を行なっているため，割り込み処理も頻繁に行われている．
したがって，実割り込みも頻繁に発生していると考えられる．
そこで，NICドライバを対象としたMintを用いた割り込みデバッグ支援環境を構築し，
割り込み処理を再現できる環境を実現する．
これにより，Mintにおける割り込み処理のデバッグ支援環境で，割り込み処理を再現する．
本稿では主に(方針1)である実割り込みの再現について設計する．

%%%%%%%%%%%%%%%%
\subsection{設計方針}\label{sec:policy_of_design}
%%%%%%%%%%%%%%%%

Mintを用いたNICドライバの割り込みデバッグ支援環境の設計方針に
ついて以下に示し，説明する．

\begin{description}
    \item[(設計方針1)] 実割り込みの再現\\
        デバッグ支援OSがデバッグ対象OSのNICドライバへ実割り込みを発生させられる
        環境を構築する．
        従来のデバッグ支援環境では，(問題1)と(問題3)がある．
        そこでNICドライバの実割り込みを再現する．
    \item[(設計方針2)] NICの動作をデバッグ支援OSが再現\\
        NICドライバの割り込み処理のデバッグを対象とするため，
        ハードウェア(NIC)のバグは考慮しない．
        したがって，NICを用いずに割り込みデバッグ支援環境を構築する．
        このため，デバッグ支援OSによりNICを再現する．
        これにより，NICを用いずにNICドライバの割り込みデバッグ支援環境を構築する．
    \item[(設計方針3)] 共有メモリを用いたパケットの受け渡し\\
        NICのパケット受信割り込みを再現するため，デバッグ対象OSで
        パケットを受け取る必要がある．
        デバッグ対象OSがパケットを受け取るには，
        入出力デバイスかメモリを用いる．
        本研究ではデバイスのバグを考慮しないため，入出力デバイスは用いない．
        そこで，デバッグ支援OSとデバッグ対象OS間の共有メモリを用いる．
        共有メモリ上にNICの受信バッファと受信ディスクリプタを
        配置することにより，デバッグ支援OSからデバッグ対象OSの
        NICドライバへパケットを受け渡す．
\end{description}

%%%%%%%%%%%%%%%%
\subsection{NICドライバのパケット受信の流れ}\label{sec:flow_of_recieving_packet_in_NIC_driver}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NICドライバのパケット受信処理流れ
\insertfigure[1]{nicnagare}{fig6}{NICドライバのパケット受信処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本研究ではNICがパケットを受信した際に発生させる割り込み(以下，パケット受信割り込み)
に対するNICドライバの割り込み処理のデバッグ支援環境を実装する．
NICによるパケットの格納と割り込み処理について図\ref{nicnagare}に示し，以下で説明する．
受信バッファはNICが受信したパケットを格納するメモリ領域である．
また，受信ディスクリプタは受信バッファへのアドレスと受信バッファがパケットを
受信済みか否かの状態(以下，受信バッファ状態)を保持するメモリ領域である．
\begin{enumerate}
    \item 
        NICが受信ディスクリプタから受信バッファのアドレスを取得する．
        これにより，NICが受信バッファにパケットを格納可能になる．
    \item 
        NICが受信バッファのアドレスをもとに，
        受信バッファへパケットを格納する．
    \item 
        NICが受信ディスクリプタ中の受信バッファ状態を更新し，
        受信済み状態にする．
        これにより，NICドライバが受信バッファがパケットを受信済みか否かを
        判別可能になる．
    \item 
        NICがNICドライバに割り込みを発生させる．これにより，OSが割り込み処理を
        開始する．
    \item 
        NICドライバが受信ディスクリプタの受信バッファ状態を確認する．
        これにより，受信バッファを特定する．
    \item 
        NICドライバが受信バッファからパケットを取得し，
        ソケットバッファへ格納する．
\end{enumerate}

%%%%%%%%%%%%%%%%
\subsection{課題}\label{sec:challenge}
%%%%%%%%%%%%%%%%

設計にあたっての課題について以下に示し，説明する．
また，各課題の項目の末尾にどの方針に対する課題かを示す．

\begin{description}
    \item[(課題1)] 割り込み間隔，回数の調整(設計方針1)\\
        実割り込みを再現するため，割り込みの間隔を調整し，連続で
        割り込みを発生させる必要がある．また，割り込みの間隔と回数を指定できる必要がある．
    \item[(課題2)] パケットの作成(設計方針2)\\
        NICドライバのパケット受信処理を再現するため，処理させるパケットを
        作成する必要がある．
    \item[(課題3)] パケットの格納(設計方針2)\\
        NICのパケットを受信バッファに格納する機能を再現するため，
        デバッグ支援OSが受信バッファにパケットを格納する必要がある．
    \item[(課題4)] 受信バッファ状態の更新(設計方針2)\\
        NICの受信ディスクリプタ中の受信バッファ状態を受信済み状態に
        書き換える機能を再現するため，デバッグ支援OSが受信バッファ状態を書き換える必要がある．
    \item[(課題5)] 割り込みの発生(設計方針2)\\
        NICのNICドライバに割り込みを発生させる機能を再現するために，
        NIC以外のものから割り込みを発生させる必要がある．
    \item[(課題6)] 割り込みハンドラの改変(設計方針2)\\
        NIC(ハードウェア)を用いないため，
        NICドライバ本来の割り込みハンドラは動作しない．
        したがって，割り込みの契機を変更する必要がある．
        また，変更した割り込み契機により動作するように割り込みハンドラを改変する必要がある．
    \item[(課題7)] 受信バッファの作成(設計方針3)\\
        デバッグ支援OSが共有メモリにパケットを配置し，
        デバッグ対象OSが共有メモリからパケットを取得するため，共有メモリに
        NICの受信バッファを作成する必要がある．
\end{description}

%%%%%%%%%%%%%%%%
\subsection{対処}\label{sec:deal}
%%%%%%%%%%%%%%%%

課題への対処を以下に示し，説明する．
また，各対処の項目の末尾に，どの課題に対する対処かを示す．

\begin{description}
    \item[(対処1)] 割り込みジェネレータによる割り込み情報の指定(課題1)\\
        割り込み間隔と回数をユーザが指定できるようにするため，
        デバッグ支援OS上にこれらの情報が指定できる割り込みジェネレータを
        APとして実装する．指定した間隔と回数で割り込みを発生させる
        システムコールを発行する．
    \item[(対処2)] 割り込みジェネレータでのパケットの作成(課題2)\\
        NICドライバが処理するパケットを作成する．
        具体的にはパケットの種類に応じたヘッダを
        データに付与する．
    \item[(対処3)] システムコールによるパケットの格納(課題3)\\
        デバッグ支援OSのシステムコールにより，デバッグ支援機構を動作させ，
        NICの受信バッファへ(対処2)のパケットを格納する．
    \item[(対処4)] システムコールによる受信バッファ状態の変更(課題4)\\
        受信バッファ状態を書き換えるため，
        受信ディスクリプタを共有メモリに配置し，デバッグ支援OSとデバッグ対象OS
        の両OSで参照可能にする．
        これにより，デバッグ支援OSが受信ディスクリプタ中の受信バッファ状態を
        書き換え可能にする．
    \item[(対処5)] 割り込み契機としてIPIを使用(課題5)\\
        NICの受信割り込みの再現として，コア間割り込みであるIPIを使用する．
        これにより，(問題1)と(問題3)を解決できる．
    \item[(対処6)] IPIを契機とした割り込みハンドラ(課題6)\\
        割り込みの契機をIPIに変更したことにより，IPIにより動作するようにNICドライバの
        割り込みハンドラを変更する必要がある．この割り込みハンドラはデバッグ対象OSが
        占有するコアがIPIを受信すると動作し，受信バッファからのパケットの取得と
        ソケットバッファへのパケット格納機能を持つ．
    \item[(対処7)] 共有メモリへ受信バッファの作成(課題7)\\
        共有メモリを用いてデバッグ支援OSとデバッグ対象OSのNICドライバ
        間でパケットを受け渡すため，NICの受信バッファを共有メモリに作成する
        必要がある．このため，NICドライバの初期化処理内で，受信バッファの
        アドレスを変更し，共有メモリのアドレスにする．
\end{description}

%%%%%%%%%%%%%%%%%
%\subsection{NICドライバのデバッグ支援環境の構成と機能}\label{sec:structure_and_function_of_DSM_of_NIC_driver}
%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% NICドライバのデバッグ支援環境の概要
%\insertfigure[0.9]{nicmintkousei}{fig7}{NICドライバのデバッグ支援環境の概要}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%Mint上でデバッグ支援OSをOSノード0，デバッグ対象OSをOSノード１として動作させる．
%デバッグ支援OSはコア0を占有し，割り込みジェネレータとデバッグ支援機構を持つ．
%デバッグ対象OSはコア1を占有し，NICドライバを持つ．
%また，メモリ上には両OSがアクセスできる共有メモリ空間が存在する．
%割り込みジェネレータ，デバッグ支援機構，およびNICドライバの構成と機能について
%図\ref{nicmintkousei}に示し，以下で説明する．
%また，各機能の項目の末尾にどの対処に対する機能かを示す．
%
%\begin{enumerate}
%    \item 割り込みジェネレータ\\
%        割り込みジェネレータはデバッグ支援OS上で動作するAPである．
%        割り込みジェネレータは以下の機能を持つ．
%        \begin{description}
%            \item[(機能1)] 割り込み情報の指定と通知(対処1)\\
%                デバッグ支援OS上で動作するAPである．
%                このAPで割り込みの間隔，割り込みの回数を指定する機能を実装する．
%                システムコールにより，デバッグ支援機構を呼び出す際にこの情報を
%                デバッグ支援機構に通知する．
%        \end{description}
%    \item デバッグ支援機構\\
%        デバッグ支援機構はデバッグ支援OSが持つ機構である．
%        これはシステムコールにより実現する．
%        デバッグ支援機構は以下の機能を持つ．
%        \begin{description}
%            \item[(機能2)] パケットの作成\\
%                通知された割り込み情報により，パケットを作成する．
%                パケットとしてデータを定義し，これにヘッダを付与
%                することでパケットを作成する．
%            \item[(機能3)] 受信バッファへのパケットの格納(対処3)\\
%                機能2で作成したパケットを共有メモリに作成された受信バッファに格納する．
%            \item[(機能4)] 受信バッファ状態の更新(対処4)\\
%                共有メモリに配置されている受信ディスクリプタを取得し，
%                その受信ディスクリプタ中の受信バッファ状態を
%                書き換え，受信済み状態にする．
%            \item[(機能5)] IPIの送信(対処5)\\
%                デバッグ支援OSが占有しているコア0に
%                コア0からデバッグ対象OSが占有しているコア1へIPIを送信する
%                要求を発行する．
%        \end{description}
%    \item NICドライバ\\
%        デバッグ対象OS内で動作している．
%        また，本環境にはNICを用いないため，
%        以下の機能を持つように改変されている．
%        \begin{description}
%            \item[(機能6)] 割り込みハンドラ(対処6)\\
%                デバッグ対象OSで動作するNICドライバにおいて
%                IPIにより動作し，共有メモリに作成された受信バッファからパケット
%                を取得し，ソケットバッファに格納する割り込みハンドラである．
%                NICドライバの初期化処理でこの割り込みハンドラを登録する．
%            \item[(機能7)] 受信バッファの作成(対処7)\\
%                デバッグ対象OSで動作するNICドライバの初期化処理中で
%                受信バッファのアドレスを決定する際に，このアドレスを共有メモリのアドレス
%                に変更する．
%        \end{description}
%\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 5章 実装
\section{実装}\label{chap:implemantation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

4章の対処を元に，デバッグ支援環境を実装した．
実装したデバッグ支援環境の処理流れを図\ref{nicmintnagare}に示し，以下で説明する．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NICドライバのデバッグ支援環境の処理流れ
\insertfigure[1.0]{nicmintnagare}{fig8}{NICドライバのデバッグ支援環境の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{enumerate}
    \item
        ユーザが割り込みジェネレータを用いて割り込み情報を指定する．
    \item 
        割り込みジェネレータがパケットを作成する．
        本実装では，作成するパケットはUDPパケットを含んだEthernetFrameである．
    \item 
        割り込みジェネレータがデバッグ支援OSのデバッグ支援機構を
        システムコールを用いて呼び出す．
        この際(1)で指定した割り込み情報と(2)で作成したパケットを引数とする．
    \item 
        デバッグ支援機構が共有メモリの受信バッファへパケットを格納する．
    \item 
        デバッグ支援機構が共有メモリの受信ディスクリプタの受信バッファ状態
        を更新する．
    \item
        デバッグ支援機構がコア0へIPI送信要求を行う．
    \item
        コア0がコア1へIPIを送信する．
    \item 
        コア1がIPIを受信すると，
        デバッグ対象OSの割り込みハンドラが動作する．
    \item 
        NICドライバが共有メモリの受信ディスクリプタ中の
        受信バッファ状態を確認する．
    \item 
        NICドライバが共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する．
\end{enumerate}
%
%%%%%%%%%%%%%%%%%
%\subsection{NICドライバのデバッグ支援環境の処理流れ}\label{sec:processing_flow_of_DSM_of_NICdriver}
%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% NICドライバのデバッグ支援環境の処理流れ
%\insertfigure[1.1]{nicmintnagare}{fig8}{NICドライバのデバッグ支援環境の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%Mintを用いたNICドライバの割り込みデバッグ支援環境の処理流れを
%図\ref{nicmintnagare}に示し，以下で説明する．
%
%\begin{enumerate}
%    \item
%        ユーザが割り込みジェネレータを用いて割り込み情報を指定する．
%    \item 
%        割り込みジェネレータがデバッグ支援OSのデバッグ支援機構を
%        システムコールを用いて呼び出す．
%        この際(1)で指定した割り込み情報を共に通知する．
%    \item 
%        デバッグ支援機構が割り込み情報からパケットを作成する．
%    \item 
%        デバッグ支援機構が共有メモリの受信バッファへパケットを格納する．
%    \item 
%        デバッグ支援機構が共有メモリの受信ディスクリプタの受信バッファ状態
%        を更新する．
%    \item
%        デバッグ支援機構がコア0へIPI送信要求を行う．
%    \item
%        コア0がコア1へIPIを送信する．
%    \item 
%        コア1がIPIを受信すると，
%        デバッグ対象OSの割り込みハンドラが動作する．
%    \item 
%        NICドライバが共有メモリの受信ディスクリプタ中の
%        受信バッファ状態を確認する．
%    \item 
%        NICドライバが共有メモリの受信バッファからパケットを取得し，
%        ソケットバッファに格納する．
%\end{enumerate}
%
%%%%%%%%%%%%%%%%%
%\subsection{必要な機能の実現}\label{sec:realization_of_needed_function}
%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%
%\subsubsection*{割り込み情報の通知}\label{sec:notification_of_interrupt_information}
%%%%%%%%%%%%%%%%%
%
%割り込みジェネレータをデバッグ支援OS上で動作するAPとして実装する．
%割り込みジェネレータでは割り込みを発生させる際の情報を指定する．
%具体的には，割り込みの種類，割り込みの間隔，および回数である．
%システムコールを用いてデバッグ支援機構を呼び出す際に，
%これらの情報を共に通知する．
%
%%%%%%%%%%%%%%%%%
%\subsubsection*{パケットの作成}\label{sec:creating_of_packet}
%%%%%%%%%%%%%%%%%
%
%デバッグ支援機構がNICドライバに割り込み処理をさせるためにパケットを作成する．
%パケットの種類は，UDPとしている．
%パケットの種類に応じた
%ヘッダをデータに付与することでパケットを作成する．
%
%%%%%%%%%%%%%%%%%
%\subsubsection*{受信バッファへのパケットの格納}\label{sec:store_packet_to_recieving_buffer}
%%%%%%%%%%%%%%%%%
%
%Mintの共有メモリを利用してパケットの受け渡しを実現する．
%デバッグ支援機構において，
%作成されたパケットを共有メモリの受信バッファに格納する．
%共有メモリへのパケットの格納はシステムコールとして定義されたデバッグ支援機構
%によって実現する．
%
%%%%%%%%%%%%%%%%%
%\subsubsection*{受信バッファ状態の更新}\label{sec:renew_recieving_descripter}
%%%%%%%%%%%%%%%%%
%
%受信バッファに関する情報は受信ディスクリプタが保持している．
%具体的には受信バッファのアドレス，および受信バッファ状態を保持している．
%NICドライバはパケットの受信処理を行う際，以下の流れで
%パケットを取得する．
%
%\begin{enumerate}
%    \item 
%        NICドライバが受信ディスクリプタ中の受信バッファ状態
%        を確認する．
%    \item
%        受信バッファ状態が受信済み状態ならばNICドライバは受信ディスクリプタ
%        から受信バッファのアドレスを取得する．
%    \item
%        NICドライバが
%        取得した受信バッファのアドレスから受信バッファにアクセスし，
%        パケットを取得する．
%\end{enumerate}
%本来はNICがパケットを受信バッファに格納した際にこの受信バッファ状態を変更する．
%本環境ではNICを使用せず，デバッグ支援OSがNICの動作を再現する.
%このため，
%デバッグ支援OSのデバッグ支援機構が共有メモリにパケットを格納した際に
%この受信バッファ状態を更新する．
%また，デバッグ支援OSが受信ディスクリプタを参照可能にするため，
%共有メモリに受信ディスクリプタを配置する必要がある．
%そこで，NICドライバの初期化処理中の受信ディスクリプタのアドレスを
%決定する処理中で共有メモリのアドレスに変更する．
%これにより，共有メモリに受信ディスクリプタが作成される．
%
%%%%%%%%%%%%%%%%%
%\subsubsection*{IPIの送信}\label{sec:send_IPI}
%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% IPIの送信
%\insertfigure[0.9]{ipi}{fig9}{IPIの送信}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%NICを用いずにデバッグ対象OSに割り込みを発生させるため，
%IPIを用いる．
%デバッグ支援OSでシステムコールとして定義されているデバッグ支援機構が
%デバッグ支援OSが占有しているコアにIPIの送信要求を発行する．
%これをコアが受け取ることでIPIが送信される．
%デバッグ対象OSで登録した割り込みハンドラのベクタ番号を
%IPIで指定することで登録した割り込みハンドラが動作する．
%IPIを送信する際の流れを図\ref{ipi}に示し，以下で説明する．
%
%\begin{enumerate}
%    \item 
%        コアの持つLAPIC(割り込みコントローラ)中のICRというIPI送信用の
%        レジスタに，ベクタ番号とLAPIC IDを書き込む．
%    \item 
%        LAPIC IDを参照し，このIDを持つコアへIPIを送信する．
%    \item 
%        コアがIPIを受信すると，指定したベクタ番号に対応した割り込みハンドラが動作する．
%\end{enumerate}
%
%%%%%%%%%%%%%%%%%
%\subsubsection*{共有メモリからパケットを取得する割り込みハンドラ}\label{sec:interrupt_handler_acquisition_packet_from_shared_memory}
%%%%%%%%%%%%%%%%%
%
%割り込みの契機を変更したことにより，NICドライバの割り込みハンドラを変更する必要がある．
%このため，IPIにより動作し，共有メモリの受信バッファからパケットを取得し，NICドライバの
%ソケットバッファに格納する割り込みハンドラを作成する．
%IPIを受信してからNICドライバのソケットバッファにパケットを格納するまでの
%流れを以下に示し，説明する．
%\begin{enumerate}
%    \item 
%        デバッグ対象OSが占有するコア1がIPIを受信する．
%    \item 
%        割り込みハンドラが動作し，共有メモリの受信ディスクリプタ内の
%        受信バッファ状態を確認する．
%    \item 
%        受信バッファ状態が受信済みの状態であれば，受信済みである受信バッファのアドレスの
%        受信バッファからパケットを取得し，ソケットバッファに格納する．
%\end{enumerate}
%
%作成した割り込みハンドラを利用するには，割り込みハンドラを登録する必要がある．
%したがってNICドライバの初期化処理中で作成したハンドラを登録する．
%この際，NICドライバのプライベート構造体を参照できるようにするため，
%NICドライバの初期化処理の関数内でNICのデバイス構造体を指定して登録する．
%
%%%%%%%%%%%%%%%%%
%\subsubsection*{受信バッファの作成}\label{sec:creating_recieving_buffer}
%%%%%%%%%%%%%%%%%
%
%Mintの共有メモリを用いてデバッグ支援OSからデバッグ対象OSのNICドライバ
%へパケットを受け渡すために，共有メモリにNICの受信バッファを
%作成する必要がある．
%これを実現するため，NICドライバの初期化処理中の
%受信バッファのアドレスを決定する処理内で共有メモリのアドレスに変更する．
%これにより，共有メモリに受信バッファが作成される．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6章 評価 
\section{評価}\label{chap:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsection{評価項目}\label{sec:item-of-evaluation}
%%%%%%%%%%%%%%%%

実装したデバッグ支援環境を以下の項目で評価する．
\begin{description}
    \item[(評価 1)]実現可能な割り込み間隔の評価
    \item[(評価 2)]割り込み間隔の精度の評価
    \item[(評価 3)]本環境の有用性の評価
\end{description}

(評価 1)では，本環境を用いることで，どの程度の短い間隔で割り込みを発生できるかを測定し，
実割り込みの再現について評価する．
送信処理にはパケットをメモリに複写する処理が含まれる．
このため，パケットサイズ毎に送信処理時間が長大し，実現できる送信間隔も長大すると
考えられる．

(評価 2)では，デバッグ支援OSで割り込み間隔を指定して連続で割り込みを発生させた際，
デバッグ対象OSにおいて，どの程度の精度で指定した割り込み間隔を実現できているかを評価する．

(評価 3)では，本環境を用いた際の有用性を示すため，NICドライバの性能測定を行う．
本環境を用いて，送信間隔を指定して連続でパケットを送信した際，その間隔ならば，
どの程度の確率でパケットを受信できるかを測定する．
また，どの程度の通信量を実現できているかを測定する．

%%%%%%%%%%%%%%%%
\subsection{実現可能な送信間隔の評価}\label{sec:interval}
%%%%%%%%%%%%%%%%

本デバッグ支援環境がどの程度の短い間隔で割り込みを発生可能かを評価する．
割り込みはIPIの送信によって発生するため，IPIの送信間隔は割り込みの発生間隔といえる．
IPIの送信はパケットの送信処理の最後に行われるため，1回の送信処理時間が割り込み発生間隔の最小値である．
ここで，パケットの送信処理とは図\ref{nicmintnagare}の(4)〜(7)である．
このため，送信処理にかかる時間を測定し，実現可能な割り込み間隔の最小値を評価する．

送信処理にはメモリ複写処理が含まれており，パケットのサイズによって送信処理が変わると考えられる．
したがって，3つのパケットサイズにおける送信処理時間を評価する．
具体的には，各パケットサイズで3000回送信処理を測定し，1000回目〜2000回目の処理時間の
平均を取ることで，処理時間とした．これは，処理の開始と終了には不確定な要素により，
処理時間が大きく変動する可能性があるためである．
測定に用いるパケットサイズは，以下の3つである．
\begin{enumerate}
    \item 1.5KB(MTUのサイズ)
    \item 8KB(受信バッファの半分のサイズ)
    \item 16KB(受信バッファのサイズ)
\end{enumerate}

結果を表\ref{tx-time}に示し，以下で説明する．
パケットのサイズが増加するに連れ，送信処理時間が増加していることが分かる．
これは，送信処理中にメモリ複写処理が含まれるためである．
%また，処理時間の大部分がメモリの複写処理であるため，処理時間とパケットサイズは
%一次関数的な関係を持っているはずである．
%これを示すため，表\ref{tx-time}をグラフにしたものを図\ref{fig:tx-time}に示す．
%図\ref{fig:tx-time}から，送信処理時間とパケットサイズは一次関数の関係にあることが分かる．
%本デバッグ支援環境では，1処理毎に表\ref{tx-time}に示している時間は必ずかかる．
%このため，各パケットサイズ毎に表\ref{tx-time}に示した以上の間隔を実現できる．
また，本デバッグ支援環境を用いて，連続でパケットを送信しようとした際に実現できる
最短の時間が表\ref{tx-time}である．
したがって，表\ref{tx-time}に示した時間以上の割り込み間隔を指定できる．

%\insertfigure[0.8]{fig:tx-time}{fig31}{パケットサイズと送信処理時間の関係}{ipi route}

\begin{table}[h]
    \caption{各パケットサイズにおける送信処理時間}
    \label{tx-time}
    \begin{center}
        \begin{tabular}{l|l}   \hline \hline 
            パケットサイズ (KB)      & 処理時間 (μs)    \\ \hline
           % 1                        & 0.175            \\
            1.5                      & 0.205            \\
           % 4                        & 0.766            \\
            8                        & 1.462            \\
           % 12                       & 2.131            \\
            16                       & 3.664            \\ \hline
        \end{tabular}
    \end{center}
\end{table}

%%%%%%%%%%%%%%%%
\subsection{割り込み間隔の精度の評価}\label{sec:interval}
%%%%%%%%%%%%%%%%

\insertfigure[0.8]{fig:mint-interval}{fig35}{38μsの間隔を指定した際の割り込み発生間隔のずれ}{ipi route}

本環境を用いて連続で割り込みを発生させた際，デバッグ対象OSでどの程度の精度で指定した割り込み間隔を実現できているかを
評価する．

実際に一方の計算機から他方の計算機へNICを用いて連続でパケットを送信すると，約38μsの間隔で割り込みが
発生していることを確認した．この際，常に割り込み間隔は安定せず，試行毎に38±2μsほどぶれていた．
また，稀に大きな外れ値があり，一定の間隔では割り込みが発生していないことを確認した．

そこで，割り込み間隔として38μsを指定し，1000回連続でデバッグ対象OSに割り込みを発生させた際，
割り込みハンドラが動作する間隔を測定し，それぞれの間隔が38μsとどれだけ差があるかを測定し，評価する．

結果を図\ref{fig:mint-interval}に示し，以下で説明する．
ほとんどの場合，指定した間隔である38μsで割り込みが発生していることが分かる．
1000回の試行で38μsから外れたものは4回であり，一番大きな外れ値が+2μsである．
38μsというスケールから見ると，この程度のズレは許容範囲内であると言える．
したがって，本環境を用いることで，安定して指定した間隔で割り込みを発生させられることがわかる．

%%%%%%%%%%%%%%%%
\subsection{本環境の有用性の評価}\label{sec:interval}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsubsection{NICドライバの性能測定}\label{sec:interval}
%%%%%%%%%%%%%%%%

本デバッグ支援環境の有用性を示すため，本環境を用いてNICドライバの性能を測定する．
以下の2つの項目で性能測定を行う．
\begin{enumerate}
    \item 各パケットサイズにおけるNICドライバで処理可能な割り込み間隔の測定
    \item 各パケットサイズにおけるNICドライバで実現可能な通信量の測定
\end{enumerate}
これらの項目を測定することにより，NICドライバの処理できる限界を調査できる．
これにより，NICドライバがどの程度高速なNICに対応できるかがわかる．

%%%%%%%%%%%%%%%%
\subsubsection{NICドライバで処理可能な割り込み間隔の測定}\label{sec:mint-interval}
%%%%%%%%%%%%%%%%
\insertfigure[0.9]{fig:driver}{fig32}{送信処理動作間隔とNICドライバにおけるパケット受信成功率の関係}{ipi route}
%指定した間隔で5000個のパケットを連続で送信することを1サイクルとし，
%間隔を増加させながら複数サイクル行うことで，すべてのパケットを受信可能な
%送信間隔を測定する．
%このとき，パケットの受信成功とは，NICドライバでパケットをソケットバッファに格納することとしている．
%パケットのサイズはMTUである1.5KB，8KB，およびNICの受信バッファのサイズである16KBの3つで行う．
指定した間隔で送信処理を5000回動作させ，NICドライバでのパケット受信成功率を求めることを1サイクルとし，
割り込み間隔を増加させながら複数サイクル行う．これにより，割り込み間隔がどの程度ならば受信成功率が
100\%になるかを測定する．受信処理にはメモリ複写処理が含まれるため，パケットサイズによって100\%になる
間隔が増加すると考えられる．このため，この試行を複数のパケットサイズで行う．
測定に使用するパケットサイズは\ref{sec:interval}節と同じ3つを用いる．

結果を図\ref{fig:driver}に示し，以下で説明する．
なお，図中の丸印は各パケットサイズで実現可能な送信間隔の最小値(表\ref{tx-time})を示しており，
これ以下の間隔は実現できないためこれ以上の間隔の結果を示している．
結果から，送信間隔を増加させるに連れ，受信成功率が1次関数的に増加していることが分かる．
また，パケットのサイズが増加すると，受信成功率が100\%になるまでの間隔が長大している．
これは，パケット受信割り込み処理中にメモリの複写が行われるためだと考えられる．

すべてのパケットを受信可能な間隔が送信処理の最小値に比べて大きいのは，受信処理には
ソケットバッファをドライバよりも上位のレイヤに送信する処理が含まれており，これに
長い時間を費やすためである．

%%%%%%%%%%%%%%%%
\subsubsection{NICドライバで実現可能な通信量}\label{sec:interval}
%%%%%%%%%%%%%%%%

連続でパケットを送信した際，各パケットサイズ毎にNICドライバで実現できる
最大の通信量を測定した．具体的には，\ref{sec:mint-interval}項と同様の方法で測定を行った際の
初めてパケット受信成功率が100\%となった際の送信処理5000回にかかった時間とパケットのサイズから各パケットの通信量を算出した．
また，同様にNICハードウェアを用いてNICドライバで処理できる最大の通信量を測定した．
この際，パケットサイズはMTUである1.5KBとした．これらを比較し，評価する．

結果を表\ref{throughput-nic}に示し，以下で説明する．
表\ref{throughput-nic}から実NICを大きく超える通信量を実現できていることがわかる．
また，最高で30Gbpsを実現できており，現在は開発されていない高速なNICをシミュレートできると考えられる．
メモリのみを用いて通信を行なっているため，このような膨大な通信量を実現できる．
測定を行った計算機のメモリ帯域幅は約130Gbpsであり，受信処理にはメモリ複写以外に長い時間を費やす処理が
含まれているため，これは妥当な結果であると言える．

\begin{table}[h]
    \caption{各パケットサイズにおける実現可能な通信量}
    \label{throughput-nic}
    \begin{center}
        \begin{tabular}{l|l}   \hline \hline 
            パケットサイズ (KB)      & 通信量 (Gbps)  \\ \hline
            %1                        & 4.6            \\
            1.5(実NIC)               & 0.92           \\
            1.5                      & 6.3            \\
            %4                        & 17.4           \\
            8                        & 22.7           \\
            %12                       & 29.6           \\
            16                       & 30.6           \\ \hline
        \end{tabular}
    \end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 7章 おわりに
\section{おわりに}\label{chap:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本稿ではMintを用いたNICドライバの割り込みデバッグ手法について述べた．
まず既存研究であるVMを用いたOSの割り込みデバッグ手法と問題点について述べた．
次にMintとMintを用いた割り込みデバッグ手法について述べた．
次に，Mintを用いたNICドライバの割り込みデバッグ環境の方針，課題，
対処，および必要な機能について述べた．
そして，Mintを用いた割り込みデバッグ環境の実装について述べた．
最後にMintを用いた割り込みデバッグ環境の評価について述べた．

Mintを用いたNICドライバの割り込みデバッグ環境では，実割り込みを発生させられる環境と，
NICを用いずパケットを授受する環境を提供する．
設計の課題として，割り込み間隔と回数の調整，パケットの作成，パケットの格納，受信バッファ状態の
更新，割り込み契機の変更，割り込みハンドラの作成，および受信バッファの作成を示した．
これらの対処として，割り込みジェネレータの作成，デバッグ支援機構の作成，IPIの送信，および
NICドライバの改変を示した．

本研究ではNICのパケット受信処理に対するNICドライバの割り込み処理をデバッグ対象とした．
これを実現する機能として，割り込みジェネレータ，パケットの作成，受信バッファへのパケットの格納，
受信バッファ状態の更新，IPIの送信，割り込みハンドラ，および受信バッファの作成について示した．
これらの機能の内，割り込みジェネレータはデバッグ支援OS上で動作するAPとして実装し，割り込み情報を
指定してデバッグ支援機構に通知することを示した．パケットの作成，受信バッファへの
パケットの格納，受信バッファ状態の更新，およびIPIの送信についてはデバッグ支援機構の機能として
動作するもので，システムコールとして実装することを示した．
割り込みハンドラ，および受信バッファの作成についてはNICドライバを改変し，実現することを示した．

実装したデバッグ支援環境を用いて，連続で割り込みを発生させた際，指定した間隔を守って，割り込みを
発生させられることを示した．また，本デバッグ支援環境がNICドライバの性能評価に有用であることを
示した．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 参考文献
\bibliographystyle{ipsjunsrt} % 情報処理学会形式(新)
\bibliography{mybibdata}

\end{document}
