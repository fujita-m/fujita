\documentclass[submit,techreq,noauthor,dvipdfmx]{ipsj}

\usepackage{graphicx}
\usepackage{dcolumn}
\usepackage{latexsym}
\usepackage{url}    % bibtex で url を使う
\urlstyle{same}     % フォントが変わる問題をなくす

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% sty/ にある研究室独自のスタイルファイル

\usepackage{jtygm}  % フォントに関する余計な警告を消す
\usepackage{nutils} % insertfigure, figef, tabref マクロ

\def\figdir{./figs} % 図のディレクトリ
\def\figext{pdf}    % 図のファイルの拡張子

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 文字に関するマクロ

\def\DesktopBookmark{\mbox{Desktop} \mbox{Bookmark}}
\def\DTB{\mbox{DTB}}
\def\WorkState{\mbox{Time} \mbox{Entry}}
\def\Task{\mbox{Task}}
\def\Recurrence{\mbox{Recurrence}}
\def\Mission{\mbox{Mission}}
\def\Job{\mbox{Job}}
\def\Duration{\mbox{Duration}}
\def\TimeEntry{\mbox{Time} \mbox{Entry}}
\def\UnifiedHistory{\mbox{Unified} \mbox{History}}
\newcommand{\Info}[1]{\mbox{（情報#1）}}
\newcommand{\Source}[1]{\mbox{（情報源#1）}}
\newcommand{\Step}[2]{\mbox{（手順#1-#2）}}
\newcommand{\Number}[1]{\mbox{（通番#1）}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}

\setcounter{巻数}{1}%vol53=2012
\setcounter{号数}{1}
\setcounter{page}{1}

\begin{document}

\title{Mintオペレーティングシステムを用いた\\NICドライバの開発支援手法の実現}

\affiliate{OU}{岡山大学大学院自然科学研究科\\
Graduate School of Natural Science and Technology, Okayama University}

\author{藤田 将輝}{Masaki Fujita}{OU}
\author{乃村 能成}{Yoshinari Nomura}{OU}
\author{谷口 秀夫}{Hideo Taniguchi}{OU}

\begin{abstract}
    割込処理は，OS機能を実現する処理の中でも非同期に発生するため，処理の再現が難しく，
    開発工数の増加を招く．仮想計算機を用いて割込をエミュレートする開発手法が提案されているが，
    この手法は，ハイパーバイザのオーバヘッドにより，短い間隔や一定間隔で発生する割込を再現できない．
    我々が研究開発しているMintオペレーティングシステムは，仮想化を用いずに複数のOSを
    走行可能である．そこで，Mintを用いて開発対象のOSとは別に開発支援用のOSを動作させることで，
    上記の問題を解決できる．具体的には，Mint上で動作する2つのOSの一方を擬似的なデバイスとし，
    その擬似デバイスが短い間隔で割込を発生させる．本稿では，割込が多発する
    NICドライバに提案手法を適用し，NICドライバの開発支援に有用であることを示す． 
\end{abstract}

\begin{jkeyword}
    仮想化，割込，開発
\end{jkeyword}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 1章 はじめに
\section{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Operating System (以下，OS)の多機能化にともなって，
OSのテストやデバッグに多くの工数が必要になっている\cite{chou2001empirical}．
特に，非同期な処理は，同じタイミングで発生しないため，再現が困難であり工数の増加を招く．
この非同期な処理の1つに割込処理がある．
割込処理の再現をする方法として，仮想計算機(以下，VM)を用いたものがある．
VMを用いることの利点は2つある．1つは，1台の計算機上で，開発を支援する
機構(以下，開発支援機構)と開発対象のOS(以下，開発対象OS)を
動作できることである．
これにより，計算機を2台用意する場合に比べ，コストを削減できる．
もう1つは，開発支援機構を開発対象OSの外部に実装できる点である．
これにより，実装上，開発支援機構が開発対象OSの影響を受けない．
しかし，VMを用いた開発支援手法では，VMとハイパーバイザ間の処理の遷移に伴う処理オーバヘッドが存在する．
なぜなら，開発支援機構が開発対象OSへ割込を挿入させたり，
開発支援機構が開発対象OSの動作を再現したりすることで，開発を支援するためである．
このため，VMを用いた開発支援手法では短い間隔や一定間隔で発生する割込のように，
処理オーバヘッドが影響する割込の再現が困難である．

そこで，ハイパーバイザの処理オーバヘッドが影響しない開発支援機構を構築する．
我々が研究開発しているMultiple Independent operating systems with New Technology (以下，Mint)\cite{senzaki}
はマルチコアCPUを搭載した計算機上で仮想化を用いずに複数のOSを動作できる．
本稿では，Mintを用いて，開発対象OSの外部に開発支援用のOS(以下，開発支援OS)を動作させ，
開発対象OSに割込を発生させることで開発を支援する手法を提案する．
また，提案手法を非同期な割込が頻繁に発生するNICドライバに適用し，評価することにより，
提案手法がNICドライバの開発に有用であることを示す．
提案手法は，仮想化による手法に比べて，ハイパーバイザの処理オーバヘッドが無いため，短い間隔や一定間隔で割込を発生できる．

%本稿では，提案手法を用いて非同期な割込が頻繁に発生するNICドライバを対象とした
%開発支援環境の実装について述べる．
%これにより，Mintを用いた割込処理の開発支援環境が
%NICドライバのテストに有用であることを示す．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2章 関連研究
\section{関連研究}\label{chap:related_reserch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
%% 2.1節 VMを用いたデバッグ支援機構
\subsection{VMを用いた開発支援環境}\label{sec:debugging_support_mechanism_with_VM}
%%%%%%%%%%%%%%%%

OSの割込に関するテストを支援する環境の既存研究としてVMを用いたものがある．
VMを用いた開発支援環境は主にバグを再現することを目的として研究されている．
VMを用いた割込開発支援環境は大きく分けて2つある．
割込挿入手法\cite{miyahara}とロギング/リプレイ手法\cite{samuel}\cite{jim}\cite{kawasaki}\cite{li2013lore}である．
これらの概要について以下で説明する．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 割込挿入手法の処理流れ
\insertfigure[1]{sonyu}{fig1}{割込挿入手法の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{description}
    \item[割込挿入手法]\mbox{}\\
        割込挿入手法は開発対象OSの他に，開発支援機構として，
        ハイパーバイザと開発支援OSが走行する．
        ユーザが開発対象OSの割込を挿入したいコード位置に
        ハイパーコールを挿入することで，割込を発生させる．
        この際，割込はVirtual Machine Control Structure (以下，VMCS)と呼ばれる
        データ構造の値を書き換えることで発生させられる．
        割込挿入手法の処理流れについて\figref{sonyu}に示し，以下で説明する．
        \begin{enumerate}
            \item
                ユーザが割込を挿入したいOSのコード位置にハイパーコールを
                挿入する．この際，割込の種類とデータを指定する．
            \item 
                開発対象OSに挿入したハイパーコールにより，開発対象OS
                がハイパーバイザの開発支援機構へ割込発生要求を行う．
                その後，開発対象OSの処理を中断し，ハイパーバイザへ処理が
                遷移する．
            \item 
                ハイパーバイザの開発支援機構が開発支援OSの開発支援機構
                へ割込に必要なデータの生成要求を行う．
            \item 
                開発支援OSの開発支援機構が割込に必要なデータを生成する．
            \item 
                開発支援OSの開発支援機構がハイパーバイザの開発支援機構
                へデータの生成完了を通知する．
            \item 
                ハイパーバイザの開発支援機構がVMCSの値を変更する．
                これにより，処理がハイパーバイザから開発対象OSへ処理が遷移する際に
                割込が発生する．
            \item 
                開発対象OSへ処理が遷移し，割込が発生する．
        \end{enumerate}

        割込挿入手法を用いた既存研究として仮想マシンモニタを用いた割込処理の
        デバッグ手法\cite{miyahara}がある．
        これは仮想マシンモニタが開発対象OSに仮想的な割込を発生させるものである．

    \item[ロギング/リプレイ手法]\mbox{}\\
        ロギング/リプレイ手法は開発対象OSの他に，開発支援機構として，
        ハイパーバイザが走行する．
        この手法は開発対象OSがバグを起こすまでの流れを保存(ロギング)し，
        再現(リプレイ)することで，バグを再現し，開発を支援する．
        ロギングの処理流れを\figref{loging}に示し，以下で説明する．

        \begin{enumerate}
            \item 
                開発対象OSに割込が発生すると，
                処理を中断し，ハイパーバイザに処理が遷移する．
            \item 
                ハイパーバイザの開発支援機構が再現情報をメモリに格納する．
            \item 
                ハイパーバイザから開発対象OSへ処理が遷移し，
                開発対象OSが中断していた割込処理を再開する．
        \end{enumerate}

        リプレイの処理流れについて\figref{replay}に示し，
        以下で説明する．

        \begin{enumerate}
            \item 
                ハイパーバイザの開発支援機構がメモリから再現情報を取得する．
            \item 
                取得した再現情報をもとに開発対象OSが割込の発生するアドレスまで
                命令を実行する．
            \item 
                ハイパーバイザの開発支援機構が再現情報の分岐回数と，現在の
                開発対象OSの分岐回数を比較する．
                比較結果により，以下の処理に分岐する．
                \begin{enumerate}
                    \renewcommand{\labelenumii}{(\Alph{enumii})}
                    \item 一致した場合，(4)へ進む．
                    \item 一致しない場合，(2)へ進む．
                \end{enumerate}
            \item 
                開発対象OSへ割込が発生する．
        \end{enumerate}

        ロギング/リプレイ手法を用いた既存研究としてTTVM\cite{samuel}，
        Aftersight\cite{jim}，Sesta\cite{kawasaki}，およびLoRe\cite{li2013lore}がある．
        TTVMは再現情報に加え，開発対象OS側のVMの状態を保存する．
        Aftersightはロギングとリプレイを異なる種類のハイパーバイザで行う．
        Sestaはロギングを行うOSの処理を追うようにしてリプレイを行うOSを走行させる．
        LoReはログのサイズと再現時間の削減を目的としている．
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ロギングの処理流れ
\insertfigure[0.9]{loging}{fig2}{ロギングの処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% リプレイの処理流れ
\insertfigure[0.9]{replay}{fig3}{リプレイの処理流れ}{Awesome Figure 1.} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
%% 2.4節 問題点
\subsection{問題点}\label{sec:problem}
%%%%%%%%%%%%%%%%

VMを用いた開発支援環境の問題点について
以下で説明する．

\begin{description}
    \item[(問題点 1)]短い割込間隔の再現が困難\\
        ロギング/リプレイ手法では，ロギングにおける開発対象OS とハイパーバイザ間
        の処理の遷移や再現情報の格納による処理オーバヘッドが発生する．このため，
        ロギングした情報における割込間隔は，CPUに発生した割込間隔よりも長大する．
        したがって，短い割込間隔の再現が困難である．

    \item[(問題点 2)]一定間隔で割込挿入が困難\\
        割込挿入手法では割込を発生させる際，OSのコードの任意の位置にハイパーコールを
        挿入することで割込を発生させる．ハイパーコールが実行されるタイミングはOSの処理速度に
        依存する．このため，複数の割込をCPUへ発生させる間隔の調整は，
        ハイパーコールの間隔を調整することで行う．この間隔をユーザが調整するのは困難である．
        したがって，一定間隔での割込挿入が困難である．

\end{description}

これらの問題点から，既存手法では短い間隔や一定間隔で複数割込を発生させる必要があるストレステストや
パフォーマンスチューニングのようなテストには使用できないと考えられる．
短い間隔や一定間隔の割込を発生させるためには，開発対象OSが開発支援機構の
処理負荷の影響を受けない環境が必要である．
また，実際の割込処理の再現をするため，これらの環境は実際の割込処理と同様の挙動をする
必要がある．

%%%%%%%%%%%%%%%%
%% 3章 Mintオペレーティングシステム
\section{Mintを用いた開発支援環境}\label{chap:Mint}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%
\subsection{Mintオペレーティングシステム}\label{sec:structure_of_Mint}
%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Mintの構成
\insertfigure[0.7]{mintkousei}{fig4}{Mintの構成}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mintオペレーティングシステムは1台の計算機上で仮想化を用いずに複数のOSを動作できる方式である．
Mintでは，1台の計算機上でプロセッサ，メモリ，およびデバイスを分割し，各OSが
占有する．Mintの構成例を\figref{mintkousei}に示し，説明する．
本稿ではMintを構成するOSをOSノードと呼ぶ．
Mintでは，最初に起動するOSをOSノード0とし，起動順にOSノード1，OSノード2，
．．．とする．

\begin{enumerate}
    \item プロセッサ\\
        コア単位で分割し，各OS ノードがコアを1 つ以上占有する．
    \item メモリ\\
        空間分割し，各OS ノードが分割領域を占有する．
    \item デバイス\\
        デバイス単位で分割し，各OS ノードが指定されたデバイスを占有する．
\end{enumerate}

このようにしてMintではマルチコアプロセッサCPUのコアを分割し，複数のLinuxを同時に走行できる．
本稿では，Mintを用いて開発対象OSの外部に開発支援OSを動作させ，
開発支援OSから開発対象OSへ割込を発生させることで開発を支援する環境を提案する．

%%%%%%%%%%%%%%
%\subsection{方針}\label{sec:policy}
%%%%%%%%%%%%%%
%
%\ref{sec:problem}節に示したVMを用いた割込開発支援手法の問題点を解決する手段としての,
%Mintを用いた開発支援環境の方針について以下に示し，説明する．
%なお，問題点の通番と方針の通番は対応している．
%\begin{description}
%    \item[(方針1)] 短い割込間隔を実現\\
%        ストレステスト等の短い割込を連続で発生させるようなテストを実施するには，
%        CPUに発生する割込間隔程度の短い間隔で割込を発生できる環境が必要である．
%        しかし，VMを用いた既存研究では\ref{sec:problem}節で述べた問題により，短い間隔の割込
%        の発生が困難である．そこでMintを用いた割込処理の開発支援環境では，開発
%        対象OSへCPUに発生する割込間隔程度の短い間隔で割込を発生できる環境を提供する．
%
%    \item[(方針2)] 一定間隔の割込を実現\\
%        テストでは，短い周期や長い周期で複数の割込を発生させる必要がある．
%        しかし，VMを用いた既存研究では\ref{sec:problem}節で述べた問題により，一定間隔での
%        割込発生が困難である．そこでMintを用いた割込処理の開発支援環境では，
%        開発対象OSへ一定間隔で割込を発生できる環境を提供する．
%
%\end{description}

%%%%%%%%%%%%%
\subsection{開発支援環境の構成と処理流れ}\label{sec:structure_and_processing_flow}
%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Mintを用いた開発支援環境の処理流れ
\insertfigure[0.9]{mintdebugnagare}{fig5}{Mintを用いた開発支援環境の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Mintを用いた開発支援環境について\figref{mintdebugnagare}に示し，
説明する．
Mint上で開発支援OSをOSノード0，開発対象OSをOSノード1として動作させる．
開発支援OSはコア0を占有し，割込管理アプリケーション(以下，割込管理AP)と開発支援機構を持つ．
開発対象OSはコア1を占有する．
この構成で下記の処理を行うことにより，割込を発生させる．

\begin{enumerate}
    \item 
        開発支援OS上で動作するアプリケーションである割込管理APを用いて
        ユーザが割込情報を指定する．
    \item 
        割込管理APがシステムコールを用いて開発支援機構を呼び出す際，
        指定した割込情報を開発支援OSの開発支援機構に通知する．   
    \item 
        開発支援機構がコア0へInter-Processor Interrupt(以下，IPI)の送信要求を行う．
    \item 
        コア0がIPIの送信要求を受けると，コア1へIPIを送信する．
    \item 
        コア1がIPIを受信すると割込処理が開始する．
\end{enumerate}
上記の構成により，短い割込間隔の再現が困難(問題点1)と一定間隔で割込挿入が困難(問題点2)を
解決でき，短い割込間隔と一定間隔の割込を実現できる．

%%%%%%%%%%%%%
\subsection{Linux改変による割込処理の挙動への影響}\label{sec:impact_to_linux}
%%%%%%%%%%%%%

Mintでは1台の計算機上で複数のLinuxを動作させるために各Linuxに
改変を加えている\cite{kitagawa}．
この際の改変は各Linuxの起動時に認識するプロセッサ，メモリ，およびデバイスを調停するための
ものである．起動終了処理にのみ変更を加えたものであり，
それ以外の機能は改変前のLinuxと同様に動作する．
したがって，Mintにおける割込処理は，改変前のLinuxの割込処理と同等であるといえる．
このため，提案手法はLinuxの開発に有用であると考えられる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 4章 NICドライバの割込開発環境の設計
\section{NICドライバの開発支援環境の設計}\label{chap:design_of_debugging_invironment_of_NIC}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsection{目的}\label{sec:purpose}
%%%%%%%%%%%%%%%%

割込処理の1つに，デバイスドライバの割込処理がある．
NICでは頻繁に通信を行なっているため，割込処理も頻繁に行われている．
また，複雑化するデバイスドライバの開発を支援する手法が重要になっている．
デバイスドライバを開発対象とした研究としてSymDrive\cite{renzelmann2012symdrive}
がある．これはデバイスを用いずにドライバのコードを網羅的に実行することで
バグを発見し，開発を支援するものである．しかし，SymDriveでは割込を発生できないため，
ストレステストやパフォーマンスチューニングのようなテストには
使用できない．
また，NICの高速化による利益を高めるためにはNICドライバやプロトコル処理を高速化させる
必要があり\cite{matsumoto2013x86}，これらを開発する際のテストが重要になっている．
そこで，NICドライバを対象とした割込開発支援環境を構築し，
ストレステストやパフォーマンスチューニングのようなテストができる環境を実現する．

%%%%%%%%%%%%%%%%
\subsection{設計方針}\label{sec:policy_of_design}
%%%%%%%%%%%%%%%%

Mintを用いたNICドライバの割込開発支援環境の設計方針に
ついて以下に示し，説明する．

\begin{description}
    \item[(設計方針1)] 指定した間隔と回数の割込発生\\
        テストでは割込の間隔と回数を指定できる必要がある．
        そこで，本開発支援環境では発生させる割込の間隔と回数を
        ユーザが指定可能な環境を提供する．
    \item[(設計方針2)] NICの動作を開発支援OSが再現\\
        NICドライバの割込処理のみを開発対象とするため，
        ハードウェア(NIC)の動作は考慮しない．
        したがって，NICを用いずに割込開発支援環境を構築する．
        そこで，開発支援OSがNICを再現することとする．
        これにより，NICを用いずにNICドライバの割込開発支援環境を構築する．
    \item[(設計方針3)] 共有メモリを用いたパケットの受け渡し\\
        NICのパケット受信割込処理を再現するため，開発支援OSから開発対象OSへパケットを送信する必要がある．
        これを実現するには，
        入出力デバイスかメモリを用いる．
        本研究ではテスト対象のデバイスの動作を考慮しないため，入出力デバイスは用いない．
        そこで，開発支援OSと開発対象OS間の共有メモリを用いる．
        共有メモリ上にNICの受信バッファを
        配置することにより，開発支援OSから開発対象OSの
        NICドライバへパケットを受け渡す．
\end{description}

%%%%%%%%%%%%%%%%
\subsection{課題}\label{sec:challenge}
%%%%%%%%%%%%%%%%

\ref{sec:policy_of_design}節に挙げたそれぞれの各設計方針についての
課題を設計方針毎に示し，以下で説明する．

\begin{description}
    \item[設計方針1]\mbox{}
        \begin{description}
            \item[(課題1)] 割込間隔と回数の調整\\
                ユーザが割込の間隔と回数を指定し，開発支援機構に
                通知する必要がある．この情報によって，開発支援機構が
                動作する．
        \end{description}
    \item[設計方針2]\mbox{}
        \begin{description}
            \item[(課題2)] パケットの作成，格納\\
                NICを用いずNICドライバのパケット受信処理を再現するため，処理させるパケットを
                作成し，受信バッファに格納する必要がある．
            \item[(課題3)] NICが保持する状態の更新\\
                NICがパケットを受信バッファに格納する際，NICは受信バッファ状態を書き換え，
                受信済みの状態にする．受信バッファ状態とは受信バッファがパケットを受信しているか否かの
                状態である．この状態は受信ディスクリプタという受信バッファを管理する構造に含まれている．
                本環境ではNICを用いないため開発支援OSが受信バッファ状態を書き換える必要がある．
            \item[(課題4)] 割込処理の発生\\
                本環境ではNICを用いないため，
                開発支援OSが，NICの機能であるOSへ割込を発生させる機能を再現する必要がある．
                また，発生させた割込にNICドライバの割込ハンドラが反応する必要がある．
        \end{description}
    \item[設計方針3]\mbox{}
        \begin{description}
            \item[(課題5)] 受信バッファの作成\\
                開発支援OSが共有メモリにパケットを配置し，
                開発対象OSが共有メモリからパケットを取得するため，共有メモリに
                NICの受信バッファを作成する必要がある．
        \end{description}
\end{description}

%%%%%%%%%%%%%%%%
\subsection{対処}\label{sec:deal}
%%%%%%%%%%%%%%%%

課題への対処を以下に示し，説明する．
また，各対処の通番は課題の通番と対応している．

\begin{description}
    \item[(対処1)] 割込管理APによる割込情報の指定\\
        割込間隔と回数をユーザが指定できるようにするため，
        開発支援OS上にこれらの情報が指定できる割込管理APを
        実装する．
        指定した間隔をシステムコールにより開発支援機構に通知する．
    \item[(対処2)] パケットの作成，格納\\
        割込管理APがパケットを作成し，作成したパケットを
        システムコールにより開発支援機構に渡す．
        その後，開発支援機構がNICドライバの受信バッファにパケットを格納する．
    \item[(対処3)] NICが保持する状態の更新\\
        受信バッファ状態を開発支援OSが書き換え可能にするため，
        NICドライバを改変し，
        受信ディスクリプタを共有メモリに配置する．これにより，開発支援OSと開発対象OS
        の両OSで受信ディスクリプタを参照可能になる．
    \item[(対処4)] 割込契機としてIPIを使用\\
        割込の契機としてコア間割込であるIPIを用いる．開発支援OSが占有する
        コアから開発対象OSが占有するコアへIPIを送信することで開発対象OSに割込処理を発生させる．
        また，IPIによりNICドライバの割込ハンドラが反応するようにNICドライバに改変を加える．
        この際の改変は割込ハンドラが動作するまでの経路を変更するものであり，
        割込ハンドラの処理自体に影響はない．
    \item[(対処5)] 共有メモリへ受信バッファの作成\\
        共有メモリを用いて開発支援OSと開発対象OSのNICドライバ
        間でパケットを受け渡すため，NICの受信バッファを共有メモリに作成する
        必要がある．このため，NICドライバに改変を加え，NICドライバの初期化処理内で受信バッファを作成する際の
        先頭アドレスを共有メモリ内の任意のアドレスとする．
        これにより，共有メモリ内に受信バッファを作成できる．
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 5章 実装
\subsection{処理流れ}\label{chap:implemantation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NICドライバの開発支援環境の処理流れ
\insertfigure[1.0]{nicmintnagare}{fig6}{NICドライバの開発支援環境の処理流れ}{Awesome Figure 1.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
開発支援環境の処理流れを\figref{nicmintnagare}に示し，以下で説明する．
\begin{enumerate}
    \item
        ユーザが割込管理APを用いて割込の間隔と回数を指定する．
    \item 
        割込管理APがパケットを作成する．
        本実装では，作成するパケットはUDPパケットを含んだEthernetFrameである．
    \item 
        割込管理APがシステムコールを用いて開発支援機構を
        呼び出す．
        この際(1)で指定した情報と(2)で作成したパケットを通知する．
    \item 
        開発支援機構が共有メモリに配置している受信ディスクリプタ内の受信バッファ状態
        を更新し，受信済みの状態にする．
    \item 
        開発支援機構が共有メモリの受信バッファへパケットを格納する．
    \item
        開発支援機構がコア0へIPI送信要求を行う．
    \item
        コア0がコア1へIPIを送信する．
    \item 
        コア1がIPIを受信すると，
        開発対象OSの割込ハンドラが動作する．
    \item 
        NICドライバが共有メモリの受信ディスクリプタ中の
        受信バッファ状態を確認する．
    \item 
        NICドライバが共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する．
\end{enumerate}
なお，連続で割込を発生させる際は開発支援機構が(4)，(5)，および(6)の処理を
指定した回数繰り返す．この連続する(4)，(5)，および(6)の処理を送信処理とする．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6章 評価 
\section{評価}\label{chap:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsection{評価項目}\label{sec:item-of-evaluation}
%%%%%%%%%%%%%%%%

実装した開発支援環境を以下の項目で評価する．
\begin{description}
    \item[(評価 1)]割込の間隔
    \item[(評価 2)]割込間隔の精度
    \item[(評価 3)]NICドライバへの適用
\end{description}

(評価 1)では，本環境を用いることで，どの程度の短い間隔で割込を発生できるかを測定し，
実現可能な割込間隔について評価する．

(評価 2)では，開発支援OSで割込間隔を指定して連続で割込を発生させた際の
開発対象OSにおいて，どの程度の精度で指定した割込間隔を実現できているかを評価する．

(評価 3)では本環境を用いてNICドライバの通信処理の性能を明らかにする．
本環境において，送信間隔を指定して連続でパケットを送信した際，指定した間隔ならば
どの程度の確率でパケットを受信できるかを評価する．
また，この測定結果からどの程度の通信量を実現できているかを評価する．

%%%%%%%%%%%%%%%%
\subsection{割込の間隔}\label{sec:interval}
%%%%%%%%%%%%%%%%

本開発支援環境がどの程度の短い間隔で割込を発生可能かを評価する．
割込はIPIの送信によって発生するため，IPIの送信間隔は割込の発生間隔といえる．
IPIの送信はパケットの送信処理の最後に行われるため，1回の送信処理時間が割込発生間隔の最小値である．
このため，送信処理にかかる時間を測定し，実現可能な割込間隔の最小値を求める．

送信処理にはメモリ複写処理が含まれており，パケットのサイズによって送信処理が変わると考えられる．
したがって，3つのパケットサイズにおける送信処理時間を測定する．
具体的には，各パケットサイズで1000回送信処理を測定し，
平均時間を取ることで，送信処理時間とした．
測定に用いるパケットサイズは，以下の3つである．
\begin{enumerate}
    \item 1.5KB(MTUのサイズ)
    \item 8KB(受信バッファの半分のサイズ)
    \item 16KB(受信バッファのサイズ)
\end{enumerate}

結果を\tabref{tx-time}に示し，以下で説明する．
パケットのサイズの増大にともなって，送信処理時間が長大していることが分かる．
これは，送信処理中にメモリ複写処理が含まれるためである．
\tabref{tx-time}の値は本開発支援環境を用いて，連続でパケットを送信しようとした際に実現できる
最短の時間であるといえる．
したがって，本環境は，\tabref{tx-time}に示した時間以上の割込間隔を実現できる．

%\insertfigure[0.8]{fig:tx-time}{fig31}{パケットサイズと送信処理時間の関係}{ipi route}

\begin{table}[h]
    \caption{各パケットサイズにおける送信処理時間}
    \label{tx-time}
    \begin{center}
        \begin{tabular}{D..{-1}|D{.}{.}{-1}}   \hline \hline 
            \multicolumn{1}{c|}{パケットサイズ (KB)}&
            \multicolumn{1}{c}{処理時間 (μs)}\\ \hline
            1.5                      & 0.205            \\
            8                        & 1.462            \\
            16                       & 3.664            \\ \hline
        \end{tabular}
    \end{center}
\end{table}

%%%%%%%%%%%%%%%%
\subsection{割込間隔の精度}\label{sec:interval}
%%%%%%%%%%%%%%%%

\insertfigure[0.8]{fig:mint-interval}{fig7}{38μsの間隔を指定した際の割込発生間隔のずれ}{ipi route}

本環境を用いて連続で割込を発生させた際，開発対象OSにおいて，どの程度の精度で指定した割込間隔を実現できているかを
評価する．

評価にあたり実計算機2台をLANケーブルで接続し，NICを用いて連続でパケットを送信し，どの程度の間隔で
割込が発生するかを調査した．
この結果，約\mbox{38μs}の間隔で割込が
発生していることを確認した．この際，常に割込間隔は安定せず，試行毎に\mbox{38±2μs}ほどぶれていた．
また，稀に大きな外れ値があり，一定の間隔では割込が発生していないことを確認した．

そこで，本環境を用いて割込間隔を\mbox{38μs}に指定し，1000回連続で開発対象OSに割込を発生させた際，
割込ハンドラが動作する間隔を測定する．これにより，それぞれの間隔が\mbox{38μs}とどれだけ差があるかを算出し，精度について評価する．

結果を\figref{fig:mint-interval}に示し，以下で説明する．
ほとんどの場合，指定した間隔である\mbox{38μs}と差がなく，指定した間隔で割込を発生できていることが分かる．
1000回の試行で\mbox{38μs}から外れたものは4回であり，一番大きな外れ値が\mbox{+2μs}である．
\mbox{38μs}から見ると，全てのずれは6.25\%以内に収まっている．

%%%%%%%%%%%%%%%%
\subsection{NICドライバへの適用}\label{sec:interval}
%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%
\subsubsection{通信処理の性能}\label{sec:interval}
%%%%%%%%%%%%%%%%

本開発環境を用いてNICドライバのテストを行う．
以下の2つの測定を行うことでNICドライバの性能をテストする．
\begin{enumerate}
    \item 処理可能な送信間隔
    \item 通信速度
\end{enumerate}
これらの項目を測定することにより，NICドライバの処理性能を明らかにする．
この調査を行うことで，本環境が高速なNICを擬似し，NICを用いずに
開発対象ドライバの処理性能をテストできることを示す．
本環境を用いてテストを行うことで，開発対象ドライバがどの程度高速なNICに
対応できるかが分かる．

%%%%%%%%%%%%%%%%
\subsubsection{処理可能な送信間隔}\label{sec:mint-interval}
%%%%%%%%%%%%%%%%
\insertfigure[1.0]{fig:driver}{fig8}{送信処理動作間隔とNICドライバにおけるパケット受信成功率の関係}{ipi route}
指定した間隔で送信処理を5000回動作させ，NICドライバでパケット受信成功率を求めることを1サイクルとし，
送信間隔を増加させながら複数サイクル行う．これにより，割込間隔と受信成功率の関係
を測定する．ここで，受信成功とはNICドライバ内でパケットをソケットバッファに格納することとする．
受信処理にはメモリ複写処理が含まれるため，パケットサイズの増大にともなって受信成功率が100\%になる
間隔が長大化すると考えられる．このため，この測定を複数のパケットサイズで行う．
測定に使用するパケットサイズは\ref{sec:interval}節と同じ以下の3つのものを用いる．
\begin{enumerate}
    \item 1.5KB(MTUのサイズ)
    \item 8KB(受信バッファの半分のサイズ)
    \item 16KB(受信バッファのサイズ)
\end{enumerate}

結果を\figref{fig:driver}に示し，以下で説明する．
なお，図中の丸印は各パケットサイズで実現可能な送信間隔の最小値(\tabref{tx-time})を示しており，
これ以下の間隔は実現できないためこれ以上の間隔の結果を示している．
結果から，送信間隔の増加にともなって，受信成功率が1次関数的に増加していることが分かる．
また，パケットのサイズの増加にともなって，受信成功率が100\%になるまでの間隔が長大化している．
これは，パケット受信割込処理中にメモリの複写が行われるためである．

すべてのパケットを受信可能な送信間隔が送信処理の最小値に比べて大きいのは，受信処理には
ソケットバッファをドライバよりも上位のレイヤに送信する処理が含まれているためである．

%%%%%%%%%%%%%%%%
\subsubsection{通信速度}\label{sec:interval}
%%%%%%%%%%%%%%%%

連続でパケットを送信した際，各パケットサイズ毎にNICドライバで実現できる
最大の通信速度を算出した．具体的には，\ref{sec:mint-interval}項の測定において
初めてパケット受信成功率が100\%となった際の送信処理5000回にかかった時間とパケットのサイズから各パケットにおける通信量を算出した．

評価にあたり，NICを用いてNICドライバで処理できる最大の通信量を測定した．
具体的には，2台の計算機をLANケーブルで接続し，一方の計算機から他方の計算機へパケットを連続で
送信した際の通信速度を測定した．
測定においてパケットサイズはMTUである1.5KBとした．

結果を\tabref{throughput-nic}に示し，以下で説明する．
\tabref{throughput-nic}から提案手法を用いた際，実NICを大きく超える通信速度を実現できていることがわかる．
また，最高で30Gbpsを実現できており，実NICより高速なNICをエミュレートできていることが分かる．

本測定環境ではメモリのみを用いて通信を行なっているため，このような膨大な通信量を実現できる．
測定を行った計算機のメモリ帯域幅は約130Gbpsである．また，受信処理にはメモリ複写以外に長い時間を費やす処理が
含まれているため，本測定は妥当な結果であるといえる．

これらの結果から，新規NICドライバ開発において開発対象ドライバを高速なNICに対応させる際に
本環境を用いることで，NICを用いずに開発対象ドライバの処理性能を測定できると考えられる．

\begin{table}[h]
    \caption{各パケットサイズにおける実現可能な通信量}
    \label{throughput-nic}
    \begin{center}
        \begin{tabular}{D..{-1}|D{.}{.}{-1}}   \hline \hline 
            \multicolumn{1}{c|}{パケットサイズ (KB)}&
            \multicolumn{1}{c}{通信量 (Gbps)}\\ \hline
            1.5 \texttt{(実NIC)}               & 0.92           \\
            1.5                      & 6.3            \\
            8                        & 22.7           \\
            16                       & 30.6           \\ \hline
        \end{tabular}
    \end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 7章 おわりに
\section{おわりに}\label{chap:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本稿ではMintを用いて，開発対象OSの外部に開発支援OSを動作させ，開発対象OSへ割込を発生させることで
開発を支援する手法を提案した．
まず，VMを用いた開発支援環境の問題点を明らかにし，短い間隔や一定間隔の割込の発生が困難であることを示した．
次に，問題点を解決する手段としてのMintを用いた開発支援環境について述べた．
最後に，提案手法をNICドライバの開発に適用し，評価することで提案手法が有用であることを示した．

Mintを用いたNICドライバの割込開発環境では，指定した間隔で割込を発生させられる環境と
NICを用いずパケットを授受する環境を提供する．
設計の課題として，割込間隔と回数の調整，パケットの作成と格納，NICの保持する状態の
更新，割込の発生，および受信バッファの作成を示した．
これらの対処として，割込管理APの作成，開発支援機構の作成，IPIの送信，および
NICドライバの改変を示した．
割込管理APは開発支援OS上で動作するAPとして実装しており，割込情報の指定とパケットの
作成を行い，システムコールを用いて開発支援機構に通知する．
開発支援機構はカーネルの機能として実装しており，NICの状態の更新，受信バッファへのパケットの格納，
およびIPI送信要求の発行を行う．
割込ハンドラの動作，および受信バッファの作成については，NICドライバを改変し実現することを示した．

実装した開発支援環境を用いて連続で割込を発生させた際，非常に短い間隔で割込を発生できることを示した．
また，指定した間隔と発生する間隔の差は6.25\%以内に収まっていることを示した．
そして，本環境を用いてNICドライバのテストを行った際，NICドライバがどの程度の
通信速度を実現できるかを調査可能であることを示した．
本環境は新規NICドライバの開発時に，NICを用いずにNICドライバの処理性能を調査するといった
使用法が考えられる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 参考文献
\bibliographystyle{ipsjunsrt} % 情報処理学会形式(新)
\bibliography{mybibdata}

\end{document}
