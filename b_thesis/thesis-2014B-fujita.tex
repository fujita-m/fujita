\documentclass[tanilab-enum]{graduate}
\usepackage{makeidx}
\usepackage[dvipdfmx]{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% sty/ にある研究室独自のスタイルファイル

\usepackage{jtygm}  % フォントに関する余計な警告を消す
\usepackage{nutils} % insertfigure, figef, tabref マクロ

\def\figdir{./figs} % 図のディレクトリ
\def\figext{pdf}    % 図のファイルの拡張子

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 学部用の所属設定

\major{岡山大学工学部 情報系学科}
\department{岡山大学工学部}
\subdepart{情報系学科}
\booktype{特別研究報告書}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 修士用の所属設定

%\major{岡山大学大学院 自然科学研究科 電子情報システム工学専攻}
%\department{岡山大学大学院 自然科学研究科}
%\subdepart{電子情報システム工学専攻}
%\booktype{修士論文}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル，索引

\title{Mintオペレーティングシステムを用いたNICドライバの割り込みデバッグ手法の実現}
\author{藤田 将輝}
\date{平成27年2月6日}

\makeindex

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\abstract{要約}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  OSのデバッグ手法としてVMを用いたものがある．これはVM上で2つのOSを走
行させ，一方のOSから他方のOSへ任意のタイミングで割り込みを発生させるこ
とにより，バグを再現し，デバッグを支援するものである．しかし，VMを用い
たデバッグ手法では，VMとハイパーバイザ間の処理の遷移に伴う処理負荷が発
生する．このため，一定間隔で連続で発生する割り込みや短い間隔で
連続で発生する割り込みのバグの
ように処理負荷が影響する割り込み処理のデバッグが困難である．

そこで，Mintを用いたOSのデバッグ手法が提案されている．
Mintは1台の計算機上で複数のOSが論理分割された計算機資源を直接操作できる．
また，割り込み処理のデバッグは困難であるが，特に非同期な割り込み処理の
デバッグは非常に困難である．
この非同期な割り込み処理が頻繁に発生するのがNICを用いた通信である．
本研究では，提案手法を用いて，NICにおける割り込みを任意に挿入できる
環境を実現する．具体的には，
デバッグを支援するOSからNICドライバが割り込み処理をするパケットを
デバッグを支援するOSとデバッグ対象のOSが共有しているメモリに格納し，
割り込み元OSが占有しているコアから割り込み先のOSが占有して
いるコアへIPIを送信することにより，割り込みハンドラが動作し，NICドライ
バが共有メモリからパケットを取得することで割り込み処理を発生させるもの
である．これにより，NICドライバの割り込みにより発生するバグを再現し，
デバッグを支援することができる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableandlists% 目次，図表目次
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}\label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
近年，OSの多機能化に伴って，OSのデバッグが重要視されている．
OSのデバッグ，特に割り込み処理に関するデバッグは非同期的な
処理であるため，デバッグが困難になっている．
このデバッグを支援する方法として，仮想計算機を用いたものがある．
仮想計算機を用いて，デバッグ支援OSとデバッグ対象OSの2つのOSを
動作させ，デバッグ支援OSがデバッグ対象OSへ割り込みを挿入させたり，
デバッグ支援OSがデバッグ対象OSの動作を再現したりすることで，
バグを再現し，デバッグを支援する．
しかし，仮想計算機を用いると，仮想計算機とハイパーバイザ間の
処理の遷移に伴う処理負荷が存在するため，一定間隔で発生する
割り込みや，短い間隔で発生するバグのように，処理負荷が影響する
割り込み処理のデバッグが困難である．

そこで，Multiple Independent operating systems with New Technology(以下，Mint)\cite{senzaki}
を用いたデバッグ手法が提案されている．
Mintは仮想化を用いずに複数のLinuxを動作できるOSである．
このため，Mintを用いてデバッグ支援環境を構築すると，
ハイパーバイザが存在しないため，処理の遷移に伴う処理負荷も
同様に存在しなくなる．
これにより，一定間隔で発生する割り込み割り込みや短い間隔で発生する
バグのデバッグが可能になる．

本論文では，非同期的な割り込みが頻繁に発生するNICドライバに
Mintを用いたデバッグ支援環境を構築することで，
NICドライバの割り込み処理のデバッグを支援する環境について述べる．
2章では仮想計算機を用いた既存研究のデバッグ手法の概要，処理流れ，
および問題点について述べる．
3章ではMintとMintを用いたデバッグ支援環境の概要，および処理流れに
ついて述べる．
4章では，Mintを用いたNICドライバの割り込みデバッグ支援環境の設計について述べる．
5章ではMintを用いたNICドライバの割り込みデバッグ支援環境の実装について
述べる．
6章ではNICドライバの割り込みデバッグ支援環境の評価について述べる．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{関連研究}\label{chap:kanren}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{仮想計算機を用いたデバッグ支援機構}
OSのデバッグを支援する環境の既存研究として仮想計算機を用いたものがある．
仮想計算機を用いたデバッグ支援環境は大きく分けて2つある．
割り込み挿入法とロギング/リプレイ手法である．
これらについて以下で説明する．
\section{概要と処理流れ}
    \subsection{割り込み挿入法の概要}
    割り込み挿入法\cite{miyahara}はハイパーバイザ上で
    動作するデバッグ支援OSと
    デバッグ対象OSによって構成される．
    プログラマがデバッグ対象OSの割り込みを挿入したいコード位置で
    ハイパーコールを挿入する．
    デバッグ対象OSの走行時に，ハイパーコールを挿入した位置で
    割り込みを発生させ，バグを再現し，デバッグを支援する．
   % \subsubsection{(処理流れ)}
    \subsection{割り込み挿入法の処理流れ}
    \insertfigure[0.8]{sonyu}{sonyu}{割り込み挿入法の処理流れ}
    {Awesome Figure 1.}

    割り込み挿入法の処理流れについて図\ref{sonyu}に示し，
    以下で説明する．
    \begin{enumerate}
        \item 割り込み発生要求\\
            デバッグ対象OSに挿入したハイパーコールにより，デバッグ対象OS
            がハイパーバイザのデバッグ支援機構へ割り込み発生要求を行う．
            その後，デバッグ対象OSの処理を中断し，ハイパーバイザへ処理が
            遷移する．
        \item データ生成要求\\
            ハイパーバイザのデバッグ支援機構がデバッグ支援OSのデバッグ支援機構
            へ割り込みに必要なデータの生成要求を行う．
            割り込みに必要なデータとは，パケットやキーコードである．
        \item データの生成\\
            デバッグ支援OSのデバッグ支援機構が割り込みに必要なデータを生成する．
        \item データ生成完了通知\\
            デバッグ支援OSのデバッグ支援機構がハイパーバイザのデバッグ支援機構
            へデータの生成完了を通知する．
        \item VMCSの変更\\
            ハイパーバイザのデバッグ支援機構がVMCSの内容を変更する．
            これにより，処理がハイパーバイザからデバッグ対象OSへ処理が遷移するとき
            割り込みが発生する．
        \item 割り込み発生\\
            デバッグ対象OSへ処理が遷移し，割り込みが発生する．
    \end{enumerate}
    \subsection{ロギング/リプレイ手法の概要}
    ロギング/リプレイ手法はハイパーバイザまたはホストOS上で動作する
    デバッグ対象OSにより構成される．
    この手法はデバッグ対象OSがバグを起こすまでの流れを保存し，
    再現することで，デバッグを支援する．
    ここでロギングとはOSの動作の流れを保存することで，
    リプレイとは保存した流れを再現することである．
    また，処理の流れを再現するための情報として，以下のような再現情報
    がある．
    \begin{enumerate}
        \item 割り込みの種類，割り込み発生アドレス，および分岐命令を経由した回数\\
            割り込みの種類とこの割り込みが発生したアドレス，および分岐命令を経由した
            回数である．
        \item 割り込み発生時に使用するデータ\\
            キーコードや，パケットなどのような割り込み処理で扱うデータである．
    \end{enumerate}
    ロギング/リプレイ手法を用いた関連研究としてTTVM\cite{samuel}，
    およびSesta\cite{kawasaki}がある．
    TTVMは再現情報に加え，デバッグ対象OS側の仮想計算機の状態を保存する．
    Sestaはロギングを行うOSの処理を追うようにしてリプレイを行うOSを走行させる．

    \subsection{ロギングの処理流れ}
    \insertfigure[0.8]{loging}{loging}{ロギングの処理流れ}
    {Awesome Figure 1.}

    ロギングの処理流れについて図\ref{loging}に示し，
    以下で説明する．
    \begin{enumerate}
        \item 割り込みの発生\\
            デバッグ対象OSに割り込みが発生すると，
            処理を中断し，ハイパーバイザに処理が遷移する．
        \item 再現情報の格納\\
            ハイパーバイザのデバッグ支援機構が再現情報をメモリに格納する．
        \item 割り込み処理の開始\\
            ハイパーバイザからデバッグ対象OSへ処理が遷移し，
            デバッグ対象OSが中断していた割り込み処理を再開する．
    \end{enumerate}
    \subsection{リプレイの処理流れ}
    \insertfigure[0.8]{replay}{replay}{リプレイの処理流れ}
    {Awesome Figure 1.} 
    リプレイの処理流れについて図\ref{replay}に示し，
    以下で説明する．
            \begin{enumerate}
                \item 再現情報の取得\\
                    ハイパーバイザのデバッグ支援機構がメモリから再現情報を取得する．
                \item 割り込み発生アドレスまでの処理の実行\\
                    取得した再現情報よりデバッグ対象OSが割り込みが発生するアドレスまで
                    命令を実行する．
                \item 分岐回数の比較\\
                    ハイパーバイザのデバッグ支援機構が再現情報の分岐回数と，現在の
                    デバッグ対象OSの分岐回数を比較する．
                \item 割り込みの発生\\
                    デバッグ対象OSへ割り込みが発生する．
            \end{enumerate}
        
\section{問題点}
% \begin{enumerate}
%     \item 仮想計算機を用いたデバッグ手法のまとめ
%     \item 仮想計算機を用いたデバッグ手法の問題点を述べる．
% \end{enumerate}
割り込み挿入法の問題点について以下で説明する．
\begin{enumerate}
    \item 実計算機上で発生する間隔での複数割り込みの発生が困難\\
        割り込み挿入法では割り込みを発生させる際，OSのコードの任意の位置にハイパーコールを
        挿入することで割り込みを発生させる．コードが実行されるタイミングはOSの処理速度に
        依存する．このため，CPUへ発生する間隔で複数の割り込みを発生させようとした際に，
        この間隔を調整するのはハイパーコールの間隔を調整することで行うが，これは非常に
        困難である．つまり，実計算機上で発生する間隔での複数の割り込み(以下，実割り込み)
        を発生させることが困難である．
\end{enumerate}
また，ロギング/リプレイ手法の問題点について以下で説明する．
\begin{enumerate}
\setcounter{enumi}{1}
    \item 任意のタイミングでの割り込み発生が困難
        ロギング/リプレイ手法は，ロギング時に発生した割り込みに対する処理をリプレイ時
        に確認できる．しかし，任意のタイミングで割り込みを発生させるためには，再現情
        報として割り込みを発生させるアドレスと分岐回数をプログラマが用意しなければな
        らない．これらの指定が困難であるため，任意のタイミングで割り込みを発生させる
        ことが困難である．
    \item 実割り込みの発生が困難
        ロギング/リプレイ手法は，ロギングにおけるデバッグ対象OS とハイパーバイザの間
        の処理の遷移や再現情報の格納による処理負荷が発生する．このため，実割り込みがロ
        ギング中に発生しないと考えられる．ロギング中に実割り込みが発生しない場合，実
        割り込みを再現するための再現情報を保存できない．このため，実割り込みの発生が
        困難である．
\end{enumerate}
これらの問題点から，割り込み処理のデバッグには，デバッグ対象OSがデバッグ支援機構の
処理負荷の影響を受けない環境が必要である．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Mintオペレーティングシステム}\label{chap:Mint}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mintの設計方針}
Mintとは1台の計算機上で仮想化を用いずに計算機資源を分割することによって
複数のLinuxを動作させる方式である．
Mintの設計方針として以下の2つが挙げられる．
\begin{enumerate}
    \item 全てのLinuxが相互に処理負荷の影響を与えない．
    \item 全てのLinuxが入出力性能を十分に利用できる．
\end{enumerate}
\section{Mintの構成}
\insertfigure[0.8]{mintkousei}{mintkousei}{Mintの構成}
{Awesome Figure 1.}

Mintでは，1台の計算機上でCPU，メモリ，およびデバイスを分割し，各OSが
占有する．Mintの構成例を図\ref{mintkousei}に示し，説明する．
Mintでは，最初に起動するOSをOSノード0とし，起動順にOSノード1，OSノード2，
．．．とする．
\begin{enumerate}
    \item CPU\\
        コア単位で分割し，各OS ノードがコアを1 つ以上占有する．
    \item メモリ
        空間分割し，各OS ノードが分割領域を占有する．
    \item デバイス\\
        デバイス単位で分割し，各OS ノードが指定されたデバイスを占有する．
\end{enumerate}
\section{Mintを用いたデバッグ支援環境}
    \subsection{目的}
    % \begin{enumerate}
    %     \item Mintを用いてデバッグ支援環境を構築することの
    %         目的を述べる．
    %     \item 具体的には，仮想計算機を用いたデバッグ支援環境の
    %         問題点を解決するためにMintを用いることを述べる．
    % \end{enumerate}
    \ref{chap:kanren}章で述べたように，割り込み処理のデバッグにはデバッグ対象OS
    がデバッグ支援機構の処理負荷の影響を受けない環境が必要である．
    そこで，仮想化を用いずに複数のLinuxを動作できるMintを用いた
    デバッグ支援環境が提案されている．Mintを用いることで，
    実割り込みの発生が可能になる．また，任意のタイミングでの割り込み
    発生も可能になる．
    \subsection{Mintを用いたデバッグ支援環境の概要}
    % \begin{enumerate}
    %     \item Mintを用いたデバッグ支援環境について図を用いて説明する．
    %     \item Mintを用いたデバッグ支援環境では，デバッグ支援OSと
    %         デバッグ対象OSが動作する．
    %     \item 任意の間隔で割り込みを挿入する方法を取る．
    % \end{enumerate}
    \insertfigure[0.8]{mintdebugkousei}{mintdebugkousei}{Mintを用いたデバッグ支援環境の概要}
    {Awesome Figure 1.}

    Mint用いたデバッグ支援環境の概要について図\ref{mintdebugkousei}に示し，説明する．
    Mintを用いたデバッグ支援環境はOSノード0としてデバッグ支援OSが，
    OSノード1としてデバッグ対象OSが動作する．デバッグ支援OSにはデバッグ支援機構があり，
    デバッグ対象OSへ割り込みを発生させる．また，割り込みジェネレータを
    デバッグ支援OSのアプリケーションとして実装している．
    これらの割り込みジェネレータ，デバッグ支援機構，デバッグ支援OS，
    およびデバッグ対象OSについて以下で説明する．
    \begin{enumerate}
        \item 割り込みジェネレータ\\
            プログラマが割り込み情報を指定する際に利用するアプリケーション
            である．なお，割り込み情報とは割り込みの種類，発生間隔，
            および発生回数を合わせた情報である．
        \item デバッグ支援機構\\
            割り込みジェネレータから通知される割り込み情報をもとに，
            デバッグ対象OS へIPIを送信する機構である．
        \item デバッグ支援OS\\
            デバッグ支援機構を実装して走行するOS である．
            ここでは，コア0 を占有して走行する．
        \item デバッグ対象OS\\
            デバッグ対象となるOS である．ここでは，コア1 を占有して
            走行する．
    \end{enumerate}
    \subsection{Mintを用いたデバッグ支援環境の処理流れ}
    \insertfigure[0.8]{mintdebugnagare}{mintdebugnagare}{Mintを用いたデバッグ支援環境の処理流れ}
    {Awesome Figure 1.}

    Mintを用いたデバッグ支援環境の処理流れを図\ref{mintdebugnagare}に示し，以下で
    説明する．
    \begin{enumerate}
        \item 割り込み情報の指定\\
            デバッグ支援OS上で動作するAPを用いてプログラマが
            割り込み情報を指定する．
        \item 割り込み情報の通知\\
            割り込みジェネレータがシステムコールを用いて
            割り込み情報をデバッグ支援OSのデバッグ支援環境に通知する．
        \item Inter-Processor Interruptの送信要求\\
            デバッグ支援機構がコア0へInter-Processor Interrupt(以下，IPI)の送信要求を行う．
        \item IPIの送信\\
            コア0がIPIの送信要求を受けると，コア1へIPIを送信する．
        \item 割り込み処理の開始\\
            コア1がIPIを受信すると割り込み処理が開始する．
    \end{enumerate}
\section{MintにおけるLinux改変によるバグの影響}
Mintでは1台の計算機上で複数のLinuxを動作させるため，各Linuxに
改変\cite{kitagawa}を加える．
この際の改変は各Linuxの起動時に認識するCPU，メモリ，およびデバイスを調停するための
ものであり，割り込み処理に変更は加えていない．したがって，MintにおけるLinux改変に
おけるバグの影響はないと考えられる．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{NICドライバの割り込みデバッグ環境の設計}\label{chap:plan}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{目的}
% \begin{enumerate}
%     \item 前章で述べたMintを用いたデバッグ支援環境をNICドライバの
%         デバッグに適用させる．
%     \item NICドライバにはバグの原因となりやすい非同期な割り込みが
%         頻繁に発生するためである．
% \end{enumerate}
割り込み処理におけるバグの原因として，非同期な割り込みがある．
非同期な割り込みとは，割り込み先と割り込み元でタイミングを合わせないで
発生する割り込みのことである．
この非同期な割り込みが頻繁に発生するのがNICドライバである．
NICドライバにMintを用いた割り込みデバッグ支援環境を構築し，
非同期な割り込みを再現することでNICドライバのデバッグを支援する．
また，本研究におけるデバッグ支援環境はNICドライバの受信処理に関する
デバッグを行うものである．
\section{NICドライバのパケット受信の流れ}
\insertfigure[0.8]{nicnagare}{nicnagare}{NICドライバのパケット受信処理流れ}
{Awesome Figure 1.}

NICがパケットを受信してからNICドライバで割り込み処理が
発生するまでの流れを図\ref{nicnagare}に示し，以下で説明する．
\begin{enumerate}
    \item 受信バッファアドレスの取得\\
        NICが受信ディスクリプタから受信バッファのアドレスを取得する．
    \item 受信バッファへのパケットの格納\\
        NICが受信バッファへパケットを格納する．
    \item 受信バッファ状態の更新\\
        NICが受信ディスクリプタの受信バッファ状態を更新し，受信済み状態にする．
    \item パケット受信割り込みの発生\\
        NICがNICドライバに割り込みを発生する．
    \item 受信バッファの特定\\
        NICドライバが受信ディスクリプタの受信バッファ状態を確認し，受信バッファを特定する．
    \item ソケットバッファへのパケットの格納\\
        NICドライバが受信バッファからソケットバッファへパケットを取得し，格納する．
\end{enumerate}
% \begin{enumerate}
%     \item NICドライバのパケット受信処理の流れについて示す．
%     \item NICがパケットを受信するとメモリ上に確保された受信バッファに
%         パケットを格納する．
%     \item NICドライバに割り込みを通知する．
%     \item NICドライバの割り込みハンドラが動作する．
%     \item 受信バッファからパケットを取得し，ソケットバッファに格納する．
%     \item パケットを上層に受け渡す．
% \end{enumerate}

       

\section{NICドライバのデバッグ支援環境の概要}
\insertfigure[0.8]{nicmintkousei}{nicmintkousei}{NICドライバのデバッグ支援環境の概要}
{Awesome Figure 1.}
NICドライバのデバッグ支援環境の概要を図\ref{nicmintkousei}に示す．
NICドライバのデバッグ支援環境はデバッグ支援OS，デバッグ対象OS，
共有メモリ，NICドライバ，デバッグ支援機構，CPU，およびアプリケーションによって
構成される．
それぞれについて以下で説明する．
\begin{enumerate}
    \item デバッグ支援OS\\
        NICドライバのデバッグを支援するOSである．
        このOSはNICの動作を擬似する．
    \item デバッグ対象OS\\
        デバッグの対象となるOSである．
        本研究ではこのOSのNICドライバの受信処理のデバッグを
        対象としている．
    \item 共有メモリ\\
        Mintの共有メモリである．
        これを用いてデバッグ支援OSからデバッグ対象OSのNICドライバへ
        パケットを受け渡す．
    \item NICドライバ\\
        デバッグ対象OS内で動作している．
        受信バッファを共有メモリとみなすように改変されている．
        また，割り込みの契機としてIPIを用いる．
    \item デバッグ支援機構\\
        ユーザが指定した情報に基づいてパケットを作成し，共有メモリに配置する．
        また，コア0へIPIの送信要求を発信する．
    \item CPU\\
        コアを分割してコア0をデバッグ支援OSに，コア1をデバッグ対象OSに占有させている．
    \item アプリケーション\\
        ユーザがパケットの種類，割り込みの発生間隔を指定する．
        この情報からデバッグ支援機構によりパケットが生成される．
\end{enumerate}

%\begin{enumerate}
%    \item デバッグ支援OSからNICを用いずにデバッグ対象OSのNICドライバへパケットを送信
%    \item デバッグ支援OSからデバッグ対象OSへ割り込みを通知
%    \item デバッグ対象OSがパケットを受け取り，割り込み処理を開始
%\end{enumerate}
\section{設計方針}
Mintを用いた割り込みデバッグ環境を構築する際の設計方針を以下に示す．
\begin{enumerate}
    \item デバッグ支援OSがNICに相当する動作を再現する．
    \item NICを用いずにデバッグ支援環境を構築する．
    \item 任意のタイミングで割り込みを発生させられる．
\end{enumerate}
\section{設計にあたっての課題}
設計にあたっての課題を以下に示す．
\begin{description}
    \item[(課題1)] 1台の計算機上で動作する2つのLinux間でのパケットの受け渡し．
    \item[(課題2)] NICを用いないため，割り込みの契機の変更．
    \item[(課題3)] 割り込みハンドラとして，受信バッファ相当のものからパケットを取得するもの
        を登録する．
    \item[(課題4)] タイミングを調整できるようにする．
\end{description}

\section{課題への対処}
課題への対処を以下に示す．
\begin{description}
    \item[(対処1)]課題1への対処としてMintの共有メモリを用いて，
        パケットの受け渡しを行う．
    \item[(対処2)]課題2への対処として，割り込みはIPIを用いて行う．
    \item[(対処3)]課題3への対処として，NICドライバを改変することにより，
        共有メモリからパケットを取得し，処理をする割り込みハンドラを
        作成し，登録する．
    \item[(対処4)]課題4の対処として，ユーザから割り込みの間隔を指定できるようにする．
\end{description}
\section{対処を実現するために必要な機能}
対処を実現するために必要な機能を以下に示す．
\begin{enumerate}
    \item 割り込みジェネレータの作成\\
        対処4を実現するために，ユーザが割り込み情報を指定するAPを作成する．
    \item 割り込みジェネレータにおいての割り込み間隔の調整\\
        対処4を実現するために，割り込みジェネレータにおいてユーザが割り込みの間隔を
        指定できるようにする．
    \item パケットの共有メモリへの格納\\
        対処1の実現として，デバッグ支援OS内のデバッグ支援機構において
        パケットを共有メモリに格納できるようにする．
    \item 受信バッファ状態の更新\\
        対処3の実現として受信ディスクリプタ内の，
        受信バッファがパケットを受信ているか否かの情報を持つ
        受信バッファ状態を更新し，受信済みの状態にする機能を実装する．
    \item IPIの送信\\
        対処2の実現として，IPIを送信し割り込みを発生させる機能を実装する．
    \item 共有メモリからパケットを取得する割り込みハンドラの作成\\
        対処3の実現として，共有メモリからパケットを取得する割り込みハンドラを
        作成する．
    \item 割り込みハンドラの登録\\
        対処4の実現として，NICドライバ内で割り込みハンドラを登録し，IPIにより
        動作できるようにする．
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{実装}\label{chap:implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NICドライバのデバッグ支援環境の処理流れ}
\insertfigure[0.8]{nicmintnagare}{nicmintnagare}{NICドライバのデバッグ支援環境の処理流れ}
{Awesome Figure 1.}

Mintを用いたNICドライバの割り込みデバッグ支援環境の処理流れを
図\ref{nicmintnagare}に示し，以下で説明する．
\begin{enumerate}
    \item 割り込み情報の指定\\
        割り込みジェネレータでユーザが割り込み情報を指定する．
    \item 割り込み情報の通知\\
        デバッグ支援OSのデバッグ支援機構に指定した割り込み情報を通知する．
    \item パケットの作成\\
        デバッグ支援機構が割り込み情報からパケットを作成する．
    \item 受信バッファへのパケットの格納\\
        デバッグ支援機構が共有メモリの受信バッファへパケットを格納する．
    \item 受信バッファ状態の更新\\
        デバッグ支援機構が共有メモリの受信ディスクリプタの受信バッファ状態
        を更新する．
    \item 割り込み発生要求\\
        デバッグ支援機構がコア0へIPI送信要求を行う．
    \item IPIの送信\\
        コア0からコア1へIPIを送信する．
    \item 割り込み処理の開始\\
        コア1がIPIを受信すると，
        デバッグ対象OSの割り込みハンドラが動作する．
    \item 受信バッファ状態の確認\\
        NICドライバが共有メモリの受信ディスクリプタ中の
        受信バッファ状態を確認する．
    \item ソケットバッファへのパケットの格納\\
        NICドライバが共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する．
\end{enumerate}

\section{必要な機能の実現}
\subsection{割り込みジェネレータ}
割り込みジェネレータはデバッグ支援OS上で動作するAPとして実装する．
割り込みジェネレータではパケットを作成する際の情報を指定する．
具体的には，割り込みの種類，割り込みの間隔，および回数である．
\subsection{割り込み間隔の調整}
割り込みジェネレータにおいて割り込みの間隔をユーザが
調整できるような機能を実装する．
具体的には連続で割り込みを発生させる際の
割り込みの間隔を調整できるようにする．

\subsection{共有メモリへの格納}
% \begin{enumerate}
%     \item 生成したパケットを共有メモリに格納する．
%     \item 格納する毎にカウンタをインクリメントし，
%         リングバッファに対応する．
% \end{enumerate}
Mintの共有メモリを利用してパケットの受け渡しを実現する．
デバッグ支援機構において割り込みジェネレータから指定された情報
により作成されたパケットを共有メモリの受信バッファに格納する．
NICドライバの受信バッファはリングバッファとなっているため，
デバッグ支援機構において擬似的な送信ディスクリプタを用意し，
これを用いてリングバッファに対応する．
また，共有メモリをNICのドライバの受信バッファとみなすため，
デバッグ対象OSのNICドライバの初期化処理中において，受信バッファの
アドレスをMintの共有メモリのアドレスに変更する．
\subsection{受信バッファ状態の更新}
% \begin{enumerate}
%     \item 受信バッファ状態(受信バッファにパケットが格納されているか
%         否かの状態)を更新し，受信済み状態にする．
%     \item 具体的には，受信ディスクリプタの先頭1ビットが
%         受信バッファ状態であるため，これを更新する．
% \end{enumerate}
受信バッファに関する情報は受信ディスクリプタという構造体が保持している．
具体的には受信バッファのアドレス，受信バッファにパケットが
格納されているか否か，という情報を持っている．
NICドライバはこの情報を元にパケットを取得する．
本来はNICがパケットを受信バッファに格納する際にこれを変更する．
本機構ではNICを使用しないため，共有メモリにパケットを格納した際に
この受信済み状態を更新する．
\subsection{IPIの送信}
% \begin{enumerate}
%     \item IPIの送信について述べる．
%     \item コアの持つLAPIC中のICRというIPI送信に用いられる
%         レジスタに，ベクタ番号とLAPIC IDを書き込む．
%     \item LAPIC IDにより，IPIを送信する．
%     \item ベクタ番号により，割り込みハンドラが動作する．
% \end{enumerate}
\insertfigure[0.8]{ipi}{ipi}{ipiの送信}
{Awesome Figure 1.}
デバッグ支援OSからデバッグ対象OSへの割り込みの契機として
IPIを利用する．
デバッグ対象OSで登録した割り込みハンドラのベクタ番号を
IPIで指定することで登録した割り込みハンドラが動作する．
IPIを送信する際の流れを図\ref{ipi}に示し，以下で説明する．
\begin{enumerate}
    \item ICRへの情報の書き込み\\
        コアの持つLAPIC(割り込みコントローラ)中のICRというIPI送信用の
        レジスタに，ベクタ番号とLAPIC IDを書き込む．
    \item IPIの送信\\
        LAPIC IDを参照し，このIDを持つコアへIPIを送信する．
    \item 割り込みハンドラの動作\\
        コアがIPIを受信すると，指定したベクタ番号に対応した割り込みハンドラが動作する．
\end{enumerate}
\subsection{共有メモリからパケットを取得する割り込みハンドラ}
IPIにより動作し，共有メモリの受信バッファからパケットを取得し，NICドライバの
ソケットバッファに格納する割り込みハンドラを作成する．
IPIを受信してからNICドライバのソケットバッファにパケットを格納するまでの
流れを以下に示し，説明する．
\begin{enumerate}
    \item IPIの受信\\
        デバッグ対象OSが占有するコア1がIPIを受信する．
    \item 割り込みハンドラの動作\\
        割り込みハンドラが動作し，共有メモリの受信ディスクリプタ内の
        受信バッファ状態を確認する．
    \item パケットの取得\\
        受信バッファ状態が受信済みの状態であれば，受信済みである受信バッファのアドレスから
        パケットを取得し，ソケットバッファに格納する．
\end{enumerate}
\subsection{割り込みハンドラの登録}
\ref{}で作成した割り込みハンドラをOSに登録する．
この際，NICドライバのプライベート構造体を参照できるようにするため，
NICドライバの初期化処理の関数内でNICのデバイス構造体を指定して登録する．
これにより，空いているIRQ番号に割り込みハンドラを登録し，
呼び出せるようになる．
\chapter{評価}\label{estimaion}
\section{目的}
Mintを用いたNICドライバの割り込みデバッグ支援環境についての評価を行う．
実際のNICを用いた割り込み処理と本研究のデバッグ支援環境の割り込み処理を
比べてどの程度の差があるのかを評価する．
これにより，バグが発生した際と同程度の計算機の状態であることを示す．
\section{項目}
評価の項目について以下に示し，説明する．
\begin{enumerate}
    \item 割り込み間隔の評価\\
        どれだけ短い間隔で連続の割り込みが発生させられるかを評価する．
        具体的には，デバッグ支援OSからデバッグ対象OSへ間隔を調整して
        割り込みを発生させ，どの程度の短さまで正常に割り込みが処理
        されるのかを評価するものである．
    \item CPU負荷の評価\\
        NICを使った実際の割り込み処理と比べて，どの程度のCPU負荷がかかって
        いるのかを評価する．
        具体的には，NICを用いた割り込み処理のCPU負荷を調査し，
        本研究のデバッグ支援環境を用いた割り込み処理のCPUが
        実際の割り込み処理のCPU負荷にどれだけ近付いているかを調査する．
\end{enumerate}
\section{割り込み間隔の評価}
    \subsection{方法}
    未着手
    \subsection{結果と考察}
    未着手
\section{CPU負荷の評価}
    \subsection{方法}
    未着手
    \subsection{結果と考察}
    未着手
\chapter{おわりに}\label{conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{enumerate}
    \item 本論文の流れを示す．
    \item Mintを用いたデバッグ支援環境の有用性を示す．
    \item 本研究ではNICドライバの割り込み処理に，Mintを用いた
        デバッグ支援環境を適用させたことを示す．
    \item 残された課題について述べる．
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acknowledgment\label{acknowledgement} % 謝辞
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

(一例)
本研究を進めるにあたり，懇切丁寧なご指導をしていただきました
乃村能成准教授に心より感謝の意を表します．
また，研究活動において，数々のご指導やご助言を与えていただいた
谷口秀夫教授，山内利宏准教授に心から感謝申し上げます．
また，日頃の研究活動において，お世話になりました研究室の
皆様に感謝いたします．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 参考文献

% bibtex を使って埋める
% https://github.com/nomlab/nompedia/wiki/tex--index#user-content-pbibtex%25E3%2581%25AE%25E4%25BD%25BF%25E3%2581%2584%25E6%2596%25B9

% \bibliographystyle{tipsj}    % 情報処理学会形式(旧)
\bibliographystyle{ipsjunsrt} % 情報処理学会形式(新)
\bibliography{mybibdata}


\end{document}
