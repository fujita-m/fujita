\documentclass[tanilab-enum]{graduate}
\usepackage{makeidx}
\usepackage[dvipdfmx]{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% sty/ にある研究室独自のスタイルファイル

\usepackage{jtygm}  % フォントに関する余計な警告を消す
\usepackage{nutils} % insertfigure, figef, tabref マクロ

\def\figdir{./figs} % 図のディレクトリ
\def\figext{pdf}    % 図のファイルの拡張子

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 学部用の所属設定

\major{岡山大学工学部 情報系学科}
\department{岡山大学工学部}
\subdepart{情報系学科}
\booktype{特別研究報告書}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 修士用の所属設定

%\major{岡山大学大学院 自然科学研究科 電子情報システム工学専攻}
%\department{岡山大学大学院 自然科学研究科}
%\subdepart{電子情報システム工学専攻}
%\booktype{修士論文}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル，索引

\title{Mintオペレーティングシステムを用いたNICドライバの割り込みデバッグ手法の実現}
\author{藤田 将輝}
\date{平成27年2月6日}

\makeindex

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\abstract{要約}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
近年，Operating Systemの多機能化により，Operating Systemの機能のバグが増加している．
そこでOperating Systemのデバッグが重要になっている．
しかし，Operating Systemのデバッグは困難であり，この理由の1つに非同期な処理である
割り込み処理がある．
非同期な処理である割り込み処理は，常に同じタイミングで発生するとは
限らないため，割り込みの再現が難しい．
そこでデバッグ手法として仮想計算機を用いたものがある．
これは仮想計算機上で2つのOperating Systemを走行させ，
一方のOperating Systemから他方のOperating Systemへ
任意のタイミングで割り込みを発生させることにより，
バグを再現し，デバッグを支援するものである．しかし，仮想計算機を用い
たデバッグ手法では，仮想計算機とハイパーバイザ間の
処理の遷移に伴う処理負荷が発生する．
このため，一定間隔で連続で発生する割り込みや短い間隔で
連続で発生する割り込みのバグの
ように処理負荷が影響する割り込み処理のデバッグが困難である．
% また，割り込み処理のデバッグは困難であるが，特に非同期な割り込み処理の
% デバッグは非常に困難である．


そこで，Mintを用いたOperating Systemのデバッグ手法が提案されている．
Mintは1台の計算機上で複数のOperating Systemが論理分割された計算機資源を直接占有して
動作する技術である．
本研究では，提案手法を用い，割り込みが頻繁に発生するNICにおいて
割り込みを任意に挿入できる環境を実現する．具体的な動作の流れは，
まずデバッグを支援するOperating SystemからNICドライバが割り込み処理をするパケットを
デバッグを支援するOperating Systemとデバッグ対象のOperating Systemが共有しているメモリに格納する．
次に，デバッグを支援するOperating Systemが占有しているコアから
デバッグ対象のOperating Systemが占有して
いるコアへコア間割り込みを用いて，割り込みを発生させることにより，
割り込みハンドラが動作し，NICドライバが
共有メモリからパケットを取得する．
以上の流れから割り込み処理を再現する．
これにより，NICドライバの割り込みにより発生するバグを再現し，
デバッグを支援することができる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableandlists% 目次，図表目次
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{はじめに}\label{chap:introduction}
近年，Operating System(以下，OS)の多機能化に伴って，OSのバグが増加している．
このため，OSのデバッグが重要になっている．
OSの機能のデバッグのうち，特に割り込み処理に関するデバッグは非同期的な
処理であるため，デバッグが困難になっている．
このデバッグを支援する方法として，仮想計算機を用いたものがある．
仮想計算機を用いることの利点は2つある．1つ目は1台の計算機上でデバッグを支援する処理を
実行する機構(以下，デバッグ支援機構)とデバッグ対象のOS(以下，デバッグ対象OS)を
動作できることである．
これにより，計算機を2台用意するためのコストを削減できる．
2つ目は，デバッグ支援機構をデバッグ対象のOSの外部に実装できる点である．
これにより，デバッグ支援環境がデバッグ対象OSのバグの影響を受けない．
この仮想計算機を用いたデバッグ支援環境は仮想計算機を用いて，
デバッグを支援するOS(以下，デバッグ支援OS)と
デバッグ対象OSの2つのOSを
動作させて行う．デバッグ支援OSがデバッグ対象OSへ割り込みを挿入させたり，
デバッグ支援OSがデバッグ対象OSの動作を再現したりすることで，
バグを再現し，デバッグを支援する．
しかし，仮想計算機を用いると，仮想計算機とハイパーバイザ間の
処理の遷移に伴う処理負荷が存在する．
このため，仮想計算機を用いたデバッグ支援環境では一定間隔で発生する
割り込みや，短い間隔で発生するバグのように，処理負荷が影響する
割り込み処理のデバッグが困難である．

そこで，Multiple Independent operating systems with New Technology(以下，Mint)\cite{senzaki}
を用いたデバッグ手法が提案されている．
Mintは仮想化を用いずに複数のLinuxを動作できる方式である．
このため，Mintを用いてデバッグ支援環境を構築すると，
ハイパーバイザが存在しないため，処理の遷移に伴う処理負荷も
同様に存在しなくなる．
これにより，一定間隔で発生する割り込み割り込みや短い間隔で発生する
バグのデバッグが可能になる．

本論文では，非同期的な割り込みが頻繁に発生するNICドライバを対象とした
Mintのデバッグ支援環境を構築し，
NICドライバの割り込み処理のデバッグを支援する．
2章では仮想計算機を用いた既存研究のデバッグ手法の構成，処理流れ，
および問題点について述べる．
3章ではMintとMintを用いたデバッグ支援環境の概要，および処理流れに
ついて述べる．
4章では，Mintを用いたNICドライバの割り込みデバッグ支援環境の設計について述べる．
5章ではMintを用いたNICドライバの割り込みデバッグ支援環境の実装について
述べる．
6章ではNICドライバの割り込みデバッグ支援環境の評価について述べる．
\chapter{関連研究}\label{chap:kanren}
\section{仮想計算機を用いたデバッグ支援機構}
OSの割り込みのデバッグを支援する環境の既存研究として仮想計算機を用いたものがある．
仮想計算機を用いた割り込みデバッグ支援環境は大きく分けて2つある．
割り込み挿入法\cite{miyahara}とロギング/リプレイ手法である．
これらの概要について以下で説明する．
\begin{description}
    \item[割り込み挿入法]\mbox{}\\
        割り込み挿入法はハイパーバイザ上で
        動作するデバッグ支援OSと
        デバッグ対象OSによって構成される．
        プログラマがデバッグ対象OSの割り込みを挿入したいコード位置で
        ハイパーコールを挿入する．
        デバッグ対象OSの走行時に，ハイパーコールを挿入した位置で
        処理が遷移し，デバッグ支援OSで割り込みに必要なデータを用意した後，
        デバッグ対象OSに割り込みを発生させ，バグを再現し，デバッグを支援する．
    \item[ロギング/リプレイ手法]\mbox{}\\
        ロギング/リプレイ手法はハイパーバイザまたはハードウェア上で
        動作するホストOSと呼ばれるOS上で動作する
        デバッグ対象OSにより構成される．
        この手法はデバッグ対象OSがバグを起こすまでの流れを保存し，
        再現することで，デバッグを支援する．
        ここでロギングとはOSの動作の流れを保存することで，
        リプレイとは保存した流れを再現することである．
        また，処理の流れを再現するための情報として，以下のような情報
        がある．これらの情報を以下，再現情報と呼ぶ．
        \begin{enumerate}
            \item 割り込みの種類，割り込み発生アドレス，および分岐命令を経由した回数\\
                割り込みの種類とこの割り込みが発生したアドレス，および分岐命令を経由した
                回数である．
            \item 割り込み発生時に使用するデータ\\
                キーコードや，パケットなどのような割り込み処理で扱うデータである．
        \end{enumerate}
        ロギング/リプレイ手法を用いた関連研究としてTTVM\cite{samuel}，
        およびSesta\cite{kawasaki}がある．
        TTVMは再現情報に加え，デバッグ対象OS側の仮想計算機の状態を保存する．
        Sestaはロギングを行うOSの処理を追うようにしてリプレイを行うOSを走行させる．

\end{description}
\section{割り込み挿入法の処理流れ}
\insertfigure[0.8]{sonyu}{sonyu}{割り込み挿入法の処理流れ}
{Awesome Figure 1.}

割り込み挿入法ではユーザが割り込みを発生させたいコード位置で
ハイパーコールを挿入する．割り込みは挿入したコード位置で発生する．
また，割り込みはVirtual Machine Control Structure(以下，VMCS)
と呼ばれるデータ構造の値を書き換えることで発生する．
デバッグ対象OSとデバッグ支援OSはハイパーバイザ内のデバッグ支援機構
でデータの授受をする．
割り込み挿入法の処理流れについて図\ref{sonyu}に示し，
以下で説明する．
\begin{enumerate}
    \item 割り込み発生要求\\
        デバッグ対象OSに挿入したハイパーコールにより，デバッグ対象OS
        がハイパーバイザのデバッグ支援機構へ割り込み発生要求を行う．
        その後，デバッグ対象OSの処理を中断し，ハイパーバイザへ処理が
        遷移する．
    \item データ生成要求\\
        ハイパーバイザのデバッグ支援機構がデバッグ支援OSのデバッグ支援機構
        へ割り込みに必要なデータの生成要求を行う．
        割り込みに必要なデータとは，パケットやキーコードである．
    \item データの生成\\
        デバッグ支援OSのデバッグ支援機構が割り込みに必要なデータを生成する．
    \item データ生成完了通知\\
        デバッグ支援OSのデバッグ支援機構がハイパーバイザのデバッグ支援機構
        へデータの生成完了を通知する．
    \item VMCSの変更\\
        ハイパーバイザのデバッグ支援機構がVMCSの内容を変更する．
        これにより，処理がハイパーバイザからデバッグ対象OSへ処理が遷移するとき
        割り込みが発生する．
    \item 割り込み発生\\
        デバッグ対象OSへ処理が遷移し，割り込みが発生する．
\end{enumerate}

\section{ロギング/リプレイ手法の処理流れ}
\subsection{ロギングの処理流れ}
\insertfigure[0.8]{loging}{loging}{ロギングの処理流れ}
{Awesome Figure 1.}

ロギングの処理流れについて図\ref{loging}に示し，
以下で説明する．
\begin{enumerate}
    \item 割り込みの発生\\
        デバッグ対象OSに割り込みが発生すると，
        処理を中断し，ハイパーバイザに処理が遷移する．
    \item 再現情報の格納\\
        ハイパーバイザのデバッグ支援機構が再現情報をメモリに格納する．
    \item 割り込み処理の開始\\
        ハイパーバイザからデバッグ対象OSへ処理が遷移し，
        デバッグ対象OSが中断していた割り込み処理を再開する．
\end{enumerate}
\subsection{リプレイの処理流れ}
\insertfigure[0.8]{replay}{replay}{リプレイの処理流れ}
{Awesome Figure 1.} 
リプレイの処理流れについて図\ref{replay}に示し，
以下で説明する．
\begin{enumerate}
    \item 再現情報の取得\\
        ハイパーバイザのデバッグ支援機構がメモリから再現情報を取得する．
    \item 割り込み発生アドレスまでの処理の実行\\
        取得した再現情報よりデバッグ対象OSが割り込みが発生するアドレスまで
        命令を実行する．
    \item 分岐回数の比較\\
        ハイパーバイザのデバッグ支援機構が再現情報の分岐回数と，現在の
        デバッグ対象OSの分岐回数を比較する．
    \item 割り込みの発生\\
        デバッグ対象OSへ割り込みが発生する．
\end{enumerate}
    
\section{問題点}\label{mondai}
割り込み挿入法の問題点について以下で説明する．
\begin{description}
    \item[(問題1)]実計算機上で発生する間隔での複数割り込みの発生が困難\\
        割り込み挿入法では割り込みを発生させる際，OSのコードの任意の位置にハイパーコールを
        挿入することで割り込みを発生させる．コードが実行されるタイミングはOSの処理速度に
        依存する．このため，CPUへ発生する間隔で複数の割り込みを発生させようとした際に，
        この間隔を調整するのはハイパーコールの間隔を調整することで行うが，
        ユーザがハイパーコールの間隔を調整することでCPUへ発生する間隔を
        調整することは非常困難である．
        つまり，実計算機上で発生する間隔での複数の割り込み(以下，実割り込み)
        を発生させることが困難である．
\end{description}
また，ロギング/リプレイ手法の問題点について以下で説明する．
\begin{description}
    \item[(問題2)]任意のタイミングでの割り込み発生が困難\\
        ロギング/リプレイ手法は，ロギング時に発生した割り込みに対する処理をリプレイ時
        に確認できる．しかし，任意のタイミングで割り込みを発生させるためには，再現情
        報として割り込みを発生させるアドレスと分岐回数をプログラマが用意しなければな
        らない．これらの指定が困難であるため，任意のタイミングで割り込みを発生させる
        ことが困難である．
    \item[(問題3)]実割り込みの発生が困難\\
        ロギング/リプレイ手法は，ロギングにおけるデバッグ対象OS とハイパーバイザの間
        の処理の遷移や再現情報の格納による処理負荷が発生する．このため，実割り込みがロ
        ギング中に発生しないと考えられる．ロギング中に実割り込みが発生しない場合，実
        割り込みを再現するための再現情報を保存できない．このため，実割り込みの発生が
        困難である．
\end{description}
これらの問題点から，割り込み処理のデバッグには，デバッグ対象OSがデバッグ支援機構の
処理負荷の影響を受けない環境が必要である．
\chapter{Mintオペレーティングシステム}\label{chap:Mint}
\section{Mintの設計方針}
Mintとは1台の計算機上で仮想化を用いずに計算機資源を論理分割することによって
複数のLinuxを動作させる方式である．
Mintの設計方針として以下の2つが挙げられる．
\begin{enumerate}
    \item 全てのLinuxが相互に処理負荷の影響を抑制
    \item 全てのLinuxが入出力性能を十分に利用可能
\end{enumerate}
\section{Mintの構成}
\insertfigure[0.8]{mintkousei}{mintkousei}{Mintの構成}
{Awesome Figure 1.}

Mintでは，1台の計算機上でCPU，メモリ，およびデバイスを分割し，各OSが
占有する．Mintの構成例を図\ref{mintkousei}に示し，説明する．
Mintでは，最初に起動するOSをOSノード0とし，起動順にOSノード1，OSノード2，
．．．とする．
\begin{enumerate}
    \item CPU\\
        コア単位で分割し，各OS ノードがコアを1 つ以上占有する．
    \item メモリ\\
        空間分割し，各OS ノードが分割領域を占有する．
    \item デバイス\\
        デバイス単位で分割し，各OS ノードが指定されたデバイスを占有する．
\end{enumerate}
\section{Mintを用いたデバッグ支援環境}
\subsection{方針}
Mintを用いたデバッグ支援環境の方針について以下に示し，説明する．
\begin{description}
    \item[(方針1)]実割り込みを発生させる環境の提供\\
        割り込みの発生間隔に依存するバグを確認するには，実割り込みを発生させる必要がある．
        しかし，仮想計算機を用いた既存研究では\ref{mondai}節で述べた問題により，実割り込み
        の発生が困難である．そこでMintを用いた割り込み処理のデバッグ支援環境では，デバッグ
        対象OSへ実割り込みを発生させる環境を提供する．
    \item[(方針2)]任意のタイミングで割り込みを発生させる環境の提供\\
        デバッグの際，デバッグ対象処理のバグの有無やバグの発生箇所を確認するために，
        デバッグ対象の処理を繰り返し実行する．しかし，割り込み処理は非同期な処理であるため
        繰り返し実行することが困難である．そこでMintを用いた割り込み処理のデバッグ支援環境
        では，任意のタイミングで割り込みを発生できる環境を提供する．
\end{description}

\subsection{Mintを用いたデバッグ支援環境の構成}
提案されているMint用いたデバッグ支援環境の構成について以下に示し，
説明する．
% Mintを用いたデバッグ支援環境はOSノード0としてデバッグ支援OSが，
% OSノード1としてデバッグ対象OSが動作する．デバッグ支援OSにはデバッグ支援機構があり，
% デバッグ対象OSへ割り込みを発生させる．また，割り込みジェネレータを
% デバッグ支援OSのアプリケーションとして実装している．
% これらの割り込みジェネレータ，デバッグ支援機構，デバッグ支援OS，
% およびデバッグ対象OSについて以下で説明する．
\begin{enumerate}
    \item 割り込みジェネレータ\\
        プログラマが割り込み情報を指定する際に利用するアプリケーション(以下，AP)
        である．この割り込みジェネレータはデバッグ支援OS上で動作するAPである．
        なお，割り込み情報とは割り込みの種類，発生間隔，
        および発生回数を合わせた情報である．
    \item デバッグ支援機構\\
        割り込みジェネレータから通知される割り込み情報をもとに，
        デバッグ対象OSへInter-Processor Interrupt(以下，IPI)を送信する
        ようにコアに要求を出す機構である．
    \item デバッグ支援OS\\
        デバッグ支援機構を実装して走行するOS である．
        ここでは，OSノード0として動作する．
    \item デバッグ対象OS\\
        デバッグ対象となるOS である．ここでは，OSノード1として動作する．
\end{enumerate}
\subsection{Mintを用いたデバッグ支援環境の処理流れ}
\insertfigure[0.8]{mintdebugnagare}{mintdebugnagare}{Mintを用いたデバッグ支援環境の処理流れ}
{Awesome Figure 1.}

Mintを用いたデバッグ支援環境の処理流れを図\ref{mintdebugnagare}に示し，以下で
説明する．
\begin{enumerate}
    \item 割り込み情報の指定\\
        デバッグ支援OS上で動作するAPである割り込みジェネレータを用いて
        ユーザが割り込み情報を指定する．
    \item 割り込み情報の通知\\
        割り込みジェネレータがシステムコールを用いてデバッグ支援機構を呼び出す際，
        指定した割り込み情報をデバッグ支援OSのデバッグ支援環境に通知する．
        これにより，指定した割り込み情報でIPIを送信できる．
    \item IPIの送信要求\\
        デバッグ支援機構がコア0へIPIの送信要求を行う．
    \item IPIの送信\\
        コア0がIPIの送信要求を受けると，コア1へIPIを送信する．
    \item 割り込み処理の開始\\
        コア1がIPIを受信すると割り込み処理が開始する．
\end{enumerate}
\section{MintにおけるLinux改変によるバグの影響}
Mintでは1台の計算機上で複数のLinuxを動作させるため，各Linuxに
改変を加えている\cite{kitagawa}．
この際の改変は各Linuxの起動時に認識するCPU，メモリ，およびデバイスを調停するための
ものであり，割り込み処理に変更は加えていない．したがって，MintにおけるLinux改変に
おけるバグの影響はないと考えられる．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{NICドライバの割り込みデバッグ環境の設計}\label{chap:plan}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{目的}
% \begin{enumerate}
%     \item 前章で述べたMintを用いたデバッグ支援環境をNICドライバの
%         デバッグに適用させる．
%     \item NICドライバにはバグの原因となりやすい非同期な割り込みが
%         頻繁に発生するためである．
% \end{enumerate}
割り込み処理の1つに，デバイスドライバの割り込み処理がある．
デバイスドライバの割り込み処理は，デバイスがOSへ非同期的に発生させる割り込みにより
実行される．
NICでは頻繁に通信を行なっているため，この割り込み処理も頻繁に行われている．
そこで，NICドライバを対象としたMintを用いた割り込みデバッグ支援環境を構築し，
割り込み処理を再現できる環境を実現する．
これにより，Mintにおける割り込み処理のデバッグ支援環境で，割り込み処理が再現できることを示す．
また，NICの割り込みには2種類ある．送信完了割り込みと受信割り込みである．
送信完了割り込み処理に関しては，送信したパケットの
パケットバッファの初期化をするだけのものであるため，
本研究では考慮しない．
したがって本研究ではNICがパケットを受信した際に発生させる割り込み(パケット受信割り込み)
に対するNICドライバの割り込み処理ののデバッグ支援環境を実装する．
\section{NICドライバのパケット受信の流れ}
\insertfigure[0.8]{nicnagare}{nicnagare}{NICドライバのパケット受信処理流れ}
{Awesome Figure 1.}

NICによるパケットの格納と割り込み処理について図\ref{nicnagare}に示し，以下で説明する．
受信バッファはNICが受信したパケットを格納するメモリ領域である．
また，受信ディスクリプタは受信バッファへのアドレスと受信バッファがパケットを
受信済みか否かの状態(以下，受信バッファ状態)を保持するメモリ領域である．
\begin{enumerate}
    \item 受信バッファアドレスの取得\\
        NICが受信ディスクリプタから受信バッファのアドレスを取得する．
        これにより，NICが受信バッファにパケットを格納可能になる．
    \item 受信バッファへのパケットの格納\\
        NICが受信バッファのアドレスをもとに，
        受信バッファへパケットを格納する．
    \item 受信バッファ状態の更新\\
        NICが受信ディスクリプタ中の受信バッファ状態を更新し，
        受信済み状態にする．
        これにより，NICドライバが受信バッファがパケットを受信済みか否かを
        判別可能になる．
    \item パケット受信割り込みの発生\\
        NICがNICドライバに割り込みを発生させる．これにより，OSが割り込み処理を
        開始する．
    \item 受信バッファの特定\\
        NICドライバが受信ディスクリプタの受信バッファ状態を確認する．
        これにより，受信バッファを特定する．
    \item ソケットバッファへのパケットの格納\\
        NICドライバが受信バッファからパケットを取得し，
        ソケットバッファへ格納する．
\end{enumerate}

% \section{NICドライバのデバッグ支援環境の構成}
% \insertfigure[0.6]{nicmintkousei}{nicmintkousei}{NICドライバのデバッグ支援環境の概要}
% {Awesome Figure 1.}
% NICドライバのデバッグ支援環境の構成を図\ref{nicmintkousei}に示す．
% NICドライバのデバッグ支援環境はデバッグ支援OS，デバッグ対象OS，
% 共有メモリ，NICドライバ，デバッグ支援機構，CPU，およびアプリケーションによって
% 構成される．
% それぞれについて以下で説明する．
% \begin{enumerate}
%     \item デバッグ支援OS\\
%         NICドライバのデバッグを支援するOSである．
%         このOSはNICの動作を擬似する．
%     \item デバッグ対象OS\\
%         デバッグの対象となるOSである．
%         本研究ではこのOSのNICドライバの受信処理のデバッグを
%         対象としている．
%     \item 共有メモリ\\
%         Mintの共有メモリである．
%         これを用いてデバッグ支援OSからデバッグ対象OSのNICドライバへ
%         パケットを受け渡す．
%     \item NICドライバ\\
%         デバッグ対象OS内で動作している．
%         受信バッファを共有メモリとみなすように改変されている．
%         また，割り込みの契機としてIPIを用いる．
%     \item デバッグ支援機構\\
%         ユーザが指定した情報に基づいてパケットを作成し，共有メモリに配置する．
%         また，コア0へIPIの送信要求を発信する．
%     \item CPU\\
%         コアを分割してコア0をデバッグ支援OSに，コア1をデバッグ対象OSに占有させている．
%     \item アプリケーション\\
%         ユーザがパケットの種類，割り込みの発生間隔を指定する．
%         この情報からデバッグ支援機構によりパケットが生成される．
% \end{enumerate}
%
\section{設計方針}\label{sekkeihousin}
Mintを用いたNICドライバの割り込みデバッグ支援機構の設計方針に
ついて以下に示し，説明する．

\begin{description}
    \item[(方針1)]実割り込みの再現\\
        デバッグ支援OSがデバッグ対象OSのNICドライバへ割り込みを発生させられる
        環境を構築する．
        従来の仮想計算機を用いたデバッグ支援環境では，ハイパーバイザへの
        処理遷移のため実割り込みが困難である．
        そこで本研究におけるNICドライバの割り込みデバッグ支援環境では
        実割り込みの再現を可能にする．

    \item[(方針2)]NICの動作をデバッグ支援OSが再現\\
        NICドライバの割り込み処理のデバッグを対象とするため，
        ハードウェア(NIC)のバグは考慮しない．
        したがって，NICを用いずに割り込みデバッグ支援環境を構築する．
        NICはパケットを受信バッファに格納し，受信ディスクリプタ中の
        受信バッファ状態を更新する機能を持っている．
        NICを用いずに割り込みデバッグ支援環境を構築するため，
        NICの機能を再現するものが必要になる．
        そこでNICの機能を再現するものがデバッグ支援OSである．
        デバッグ支援OSがNICの機能を再現することでNICを用いずに
        NICドライバの割り込みデバッグ支援環境を構築する．

    \item[(方針3)]共有メモリを用いてのパケットの受け渡し\\
        NICの動作をデバッグ支援OSが再現するため，
        Mint上で動作する2つのOS間でパケットの受け渡しが必要になる．
        これを可能にするため，両OS間の共有メモリを用いる．
        共有メモリ上にNICの受信バッファと受信ディスクリプタを
        配置することにより，デバッグ支援OSからデバッグ対象OSの
        NICドライバへパケットを受け渡す．

\end{description}


\section{設計にあたっての課題}\label{kadai}
% 設計にあたっての課題を以下に示す．
% \begin{description}
%     \item[(課題1)] 1台の計算機上で動作する2つのLinux間でのパケットの授受
%     \item[(課題2)] NICを用いないため，割り込みの契機を変更．
%     \item[(課題3)] 割り込みハンドラとして，受信バッファ相当のものからパケットを取得するもの
%         を登録
%     \item[(課題4)] 割り込みの間隔の調整
% \end{description}
それぞれの設計についての課題について以下に示し，説明する．
なお，課題名の末尾に\ref{sekkeihousin}節の方針のうち，どの方針に対する課題かを示している．
\begin{description}
    \item[(課題1)]割り込み間隔，回数の調整(設計1)\\
        実割り込みを再現するためには割り込みの間隔を調整し，連続で
        割り込みを発生させる必要がある．また，割り込みの間隔と回数を指定できる環境
        を作成する必要がある．
    \item[(課題2)]パケットの作成(方針2)\\
        NICドライバのパケット受信処理を再現するためには，処理させるパケットを
        作成する機能を実装する必要がある．
    \item[(課題3)]パケットの格納(方針2)\\
        NICの機能のパケットを受信バッファに格納する機能を再現するために，
        デバッグ支援OSが受信バッファにパケットを格納する機能を実装する必要がある．
    \item[(課題4)]受信バッファ状態の更新(方針2)\\
        NICの機能の受信ディスクリプタ中の受信バッファ状態を受信済み状態に
        書き換える機能を再現するために，デバッグ支援OSが受信バッファ状態を書き換える機能を
        実装する必要がある．
    \item[(課題5)]割り込みの発生(方針2)\\
        NICの機能のNICドライバに割り込みを発生させる機能を再現するために，
        NIC以外のものから割り込みを発生させる必要がある．
    \item[(課題6)]割り込みハンドラの作成(方針2)\\
        NIC以外のものからパケット受信割り込みを発生させることにより，
        NICドライバ本来の割り込みハンドラは動作しない．
        したがって，変更した割り込み契機により動作する割り込みハンドラを実装する必要がある．
    \item[(課題7)]受信バッファの作成(方針3)\\
        デバッグ支援OSが共有メモリにパケットを配置し，
        デバッグ対象OSが共有メモリからパケットを取得するために，共有メモリに
        NICの受信バッファを作成する必要がある．
\end{description}

\section{課題への対処}\label{taisyo}
課題への対処を以下に示し，説明する．
また，対処名の末尾に\ref{kadai}節の課題のうち，どの課題に対する対処かを示している．

% \begin{description}
%     \item[(対処1)]課題1への対処としてMintの共有メモリを用いての，
%         パケットの授受
%     \item[(対処2)]課題2への対処として，割り込みはIPIを使用
%     \item[(対処3)]課題3への対処として，NICドライバを改変することにより，
%         共有メモリからパケットを取得し，処理をする割り込みハンドラを
%         作成し，登録
%     \item[(対処4)]課題4の対処として，ユーザから割り込みの間隔を指定可能
% \end{description}
\begin{description}
    \item[(対処1)]割り込みジェネレータによる指定(課題1)\\
        割り込み間隔と回数をユーザが指定できるようにするため，
        デバッグ支援OS上にこれらの情報が指定できる割り込みジェネレータを
        APとして実装する．指定した間隔で指定した回数割り込みを発生させる
        システムコールを発行する．
    \item[(対処2)]システムコール内でのパケットの作成(課題2)\\
        NICドライバで処理されるパケットは，パケット中のデータ部分のみ
        である．そこで適当なデータを用意することでNICドライバが処理をする
        パケットとする．
    \item[(対処3)]システムコールによるパケットの格納(課題3)\\
        NICの受信バッファへのパケットの格納はデバッグ支援OSのシステムコールに
        より実現する．対処2により作成されたパケットを共有メモリ上に作成した
        受信バッファに配置する．
    \item[(対処4)]システムコールによる受信バッファ状態の変更(課題4)\\
        受信バッファ状態をデバッグ支援OSで書き換えるために，
        受信ディスクリプタを共有メモリに配置し，デバッグ支援OSとデバッグ対象OS
        両OSで参照可能にする．
        これにより，デバッグ支援OSが受信ディスクリプタ中の受信バッファ状態を
        書き換え可能になる．
    \item[(対処5)]割り込み契機としてIPIを使用(課題5)\\
        NICの受信割り込みの再現として，コア間割り込みであるIPIを使用する．
        IPIは仮想計算機における割り込みのようにハイパーバイザとOS間の処理の
        遷移は存在しないため，実割り込みの再現が可能になる．
    \item[(対処6)]IPIにより動作し，共有メモリからパケットを取得する割り込みハンドラ(課題6)\\
        割り込みの契機をIPIに変更したことにより，IPIにより動作するNICドライバの
        割り込みハンドラを作成する．この割り込みハンドラはデバッグ対象OSが
        占有するコアがIPIを受信すると
        動作し，共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する機能を持つ．
        この割り込みハンドラをNICドライバの初期化処理の中で登録し，使用可能にする．
    \item[(対処7)]共有メモリへの受信バッファの作成(課題7)\\
        共有メモリを用いてデバッグ支援OSとデバッグ対象OSのNICドライバ
        間でパケットを受け渡すために，NICの受信バッファを共有メモリに作成する
        必要がある．このために，NICドライバの初期化処理内で，受信バッファの
        アドレスを変更し，共有メモリのアドレスにする．

\end{description}
\section{NICドライバのデバッグ支援環境の構成と機能}
\insertfigure[0.6]{nicmintkousei}{nicmintkousei}{NICドライバのデバッグ支援環境の概要}
{Awesome Figure 1.}

NICドライバのデバッグ支援環境の構成と機能について
図\ref{nicmintkousei}に示し，以下で説明する．
また，機能の項目名の末尾に\ref{taisyo}節で示したどの対処
に対する機能かを示している．
\begin{enumerate}
    \item 割り込みジェネレータ\\
        割り込みジェネレータはデバッグ支援OS上で動作するAPである．
        ユーザがパケットの種類，割り込みの発生間隔を指定する．
        指定した情報をシステムコールにより通知する．
        この情報からデバッグ支援機構によりパケットが生成される．
        割り込みジェネレータは以下の機能を持つ．
        \begin{description}
            \item[(機能1)]割り込み情報の通知(対処1)\\
                デバッグ支援OS上で動作するAPである．
                このAPで割り込みの間隔，割り込みの回数を指定する機能を実装する．
                これをシステムコールにより，デバッグ支援機構に通知する．
        \end{description}
    \item デバッグ支援機構\\
        デバッグ支援機構はデバッグ支援OSが持つ機構である．
        通知された割り込み情報に基づいて以下の機能を実行する．
        以下の機能は全てシステムコールにより実現する．
        \begin{description}
            \item[(機能2)]パケットの作成(対処2)\\
                通知された割り込み情報により，パケットを定義する．
                パケットとしてデータ，ヘッダ，およびフッタを作成
                する．

            \item[(機能3)]受信バッファへのパケットの格納(対処2)\\
                機能2で作成されたパケットを共有メモリに作成された受信バッファに格納する．
                これにより，NICドライバがパケットを取得可能になる．
            \item[(機能4)]受信バッファ状態の更新(対処4)\\
                共有メモリに配置されている受信ディスクリプタを取得し，
                その受信ディスクリプタ中の受信バッファ状態を
                書き換え，受信済み状態にする．
            \item[(機能5)]IPIの送信(対処5)\\
                デバッグ支援OSが占有しているコア0に
                コア0からデバッグ対象OSが占有しているコア1へIPIの送信
                要求を発行する．
        \end{description}
    \item NICドライバ\\
        デバッグ対象OS内で動作している．
        受信バッファを共有メモリとみなすように改変されている．
        また，NICを用いないため，NICからの受信割り込み割り込みが発生しない．
        このため，割り込みの契機としてIPIを用いる．
        NICドライバに実装した機能を以下に示す．
        \begin{description}
            \item[(機能6)]割り込みハンドラ(対処6)\\
                デバッグ対象OSで動作するNICドライバにおいて
                IPIにより動作し，共有メモリに作成された受信バッファからパケット
                を取得し，ソケットバッファに格納する機能を持つ割り込みハンドラを実装する．
                また，NICドライバの初期化処理中でこの割り込みハンドラを登録する．
            \item[(機能7)]受信バッファの作成(対処7)\\
                デバッグ対象OSで動作するNICドライバの初期化処理中で
                受信バッファのアドレスを決定する際に，このアドレスを共有メモリのアドレス
                に変更する．
        \end{description}
    \item デバッグ支援OS\\
        NICドライバのデバッグを支援するOSである．
        このOSはデバッグ支援機構を実装しており，NICの動作を再現する．
    \item デバッグ対象OS\\
        デバッグの対象となるOSである．
        本研究ではこのOSにロードされたNICドライバの受信処理のデバッグを
        対象としている．
    \item 共有メモリ\\
        Mintにおける共有メモリであり，デバッグ支援OSとデバッグ対象OSの両OSが
        この共有メモリにアクセスできる．
        この共有メモリにNICの受信バッファを作成する．
        これによりデバッグ支援OSからデバッグ対象OSのNICドライバへ
        パケットを受け渡す．
    \item CPU\\
        コアを分割してコア0をデバッグ支援OSに，コア1をデバッグ対象OSに占有させている．
        デバッグ支援機構により，コア0へIPIの送信要求が発行されると，コア0からコア1へ
        IPIが送信される．
\end{enumerate}

% \begin{enumerate}
%     \item パケットの共有メモリへの格納\\
%         対処1の実現として，デバッグ支援OS内のデバッグ支援機構において
%         パケットを共有メモリに格納できるようにする．
%     \item IPIの送信\\
%         対処2の実現として，IPIを送信し割り込みを発生させる機能を実装する．
%     \item 受信バッファ状態の更新\\
%         対処3の実現として受信ディスクリプタ内の，
%         受信バッファがパケットを受信ているか否かの情報を持つ
%         受信バッファ状態を更新し，受信済みの状態にする機能を実装する．
%     \item 共有メモリからパケットを取得する割り込みハンドラの作成\\
%         対処3の実現として，共有メモリからパケットを取得する割り込みハンドラを
%         作成する．
%     \item 割り込みジェネレータの作成\\
%         対処4を実現するために，ユーザが割り込み情報を指定するAPを作成する．
%     \item 割り込みハンドラの登録\\
%         対処4の実現として，NICドライバ内で割り込みハンドラを登録し，IPIにより
%         動作できるようにする．
%     \item 割り込みジェネレータにおいての割り込み間隔の調整\\
%         対処4を実現するために，割り込みジェネレータにおいてユーザが割り込みの間隔を
%         指定できるようにする．
% \end{enumerate}
% \begin{description}
%     \item[(機能1)]割り込みジェネレータ\\
%         対処1の実現として，デバッグ支援OS上で動作するAPを作成し，
%         このAPで割り込みの間隔，割り込みの回数を指定する機能を実装する．
%         これをシステムコールにより，デバッグ支援機構に通知する．
%     \item[(機能2)]パケットの作成\\
%         対処2の実現として，デバッグ支援OS内にデバッグ支援機構を
%         システムコールとして実装し，その処理においてパケットのデータを
%         定義する機能を実装する．
%     \item[(機能3)]受信バッファへのパケットの格納\\
%         対処3の実現として，デバッグ支援機構の処理において機能2で
%         作成したパケットを共有メモリに作成された受信バッファに格納する
%         機能を実装する．
%     \item[(機能4)]受信バッファ状態の更新\\
%         対処4の実現として，デバッグ支援機構の処理において共有メモリに配置されている
%         受信ディスクリプタを取得し，その受信ディスクリプタ中の受信バッファ状態を
%         書き換え，受信済み状態にする機能を実装する．
%     \item[(機能5)]IPIの送信\\
%         対処5の実現として，デバッグ支援機構が，デバッグ支援OSが占有している
%         コア0にコア0からデバッグ対象OSが占有しているコア1へIPIの送信
%         要求を発行する機能を実装する．
%     \item[(機能6)]割り込みハンドラ\\
%         対処6の実現として，デバッグ対象OSで動作するNICドライバにおいて
%         IPIにより動作し，共有メモリに作成された受信バッファからパケット
%         を取得し，ソケットバッファに格納する機能を持つ割り込みハンドラを実装する．
%         また，NICドライバの初期化処理中でこの割り込みハンドラを登録する．
%     \item[(機能7)]受信バッファの作成\\
%         対処7の実現として，デバッグ対象OSで動作するNICドライバの初期化処理中で
%         受信バッファのアドレスを決定する際に，このアドレスを共有メモリのアドレス
%         に変更する．
% \end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{実装}\label{chap:implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NICドライバのデバッグ支援環境の処理流れ}
\insertfigure[0.8]{nicmintnagare}{nicmintnagare}{NICドライバのデバッグ支援環境の処理流れ}
{Awesome Figure 1.}

Mintを用いたNICドライバの割り込みデバッグ支援環境の処理流れを
図\ref{nicmintnagare}に示し，以下で説明する．
\begin{enumerate}
    \item 割り込み情報の指定\\
        割り込みジェネレータでユーザが割り込み情報を指定する．
    \item 割り込み情報の通知\\
        割り込みジェネレータがデバッグ支援OSのデバッグ支援機構を
        システムコールを用いて呼び出す．
        この際(1)で指定した割り込み情報を共に通知する．
    \item パケットの作成\\
        デバッグ支援機構が割り込み情報からパケットを作成する．
    \item 受信バッファへのパケットの格納\\
        デバッグ支援機構が共有メモリの受信バッファへパケットを格納する．
    \item 受信バッファ状態の更新\\
        デバッグ支援機構が共有メモリの受信ディスクリプタの受信バッファ状態
        を更新する．
    \item 割り込み発生要求\\
        デバッグ支援機構がコア0へIPI送信要求を行う．
    \item IPIの送信\\
        コア0がコア1へIPIを送信する．
    \item 割り込み処理の開始\\
        コア1がIPIを受信すると，
        デバッグ対象OSの割り込みハンドラが動作する．
    \item 受信バッファ状態の確認\\
        NICドライバが共有メモリの受信ディスクリプタ中の
        受信バッファ状態を確認する．
    \item ソケットバッファへのパケットの格納\\
        NICドライバが共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する．
\end{enumerate}

\section{必要な機能の実現}

\subsection{割り込み情報の通知}
割り込みジェネレータをデバッグ支援OS上で動作するAPとして実装する．
割り込みジェネレータではパケットを作成する際の情報を指定する．
具体的には，割り込みの種類，割り込みの間隔，および回数である．
システムコールを用いてデバッグ支援機構を呼び出す際に，
これらの情報を共に通知する．

\subsection{パケットの作成}\label{packet}
% NICドライバはパケットのデータ部をソケットバッファに格納し，
% ソケットバッファを上の層に送ることで割り込み処理を終了する．
% したがって，データ部をパケットとして用意できればよい．
% そこで，適当なデータを定義し，パケットとしている．
NICドライバに割り込み処理をさせるためにパケットを作成する．
パケットの種類は，UDPとしている．
データを定義し，このデータに種類に応じた
ヘッダ，およびフッタを付与することでパケットを作成する．
\subsection{受信バッファへのパケットの格納}
Mintの共有メモリを利用してパケットの受け渡しを実現する．
デバッグ支援機構において，\ref{packet}節で
作成されたパケットを共有メモリの受信バッファに格納する．
共有メモリへのパケットの格納はシステムコールにより定義されたデバッグ支援機構
によって実現する．
NICドライバの受信バッファはリングバッファとなっているため，
デバッグ支援機構において擬似的な送信ディスクリプタを用意し，
これを用いてリングバッファに対応する．

\subsection{受信バッファ状態の更新}
% \begin{enumerate}
%     \item 受信バッファ状態(受信バッファにパケットが格納されているか
%         否かの状態)を更新し，受信済み状態にする．
%     \item 具体的には，受信ディスクリプタの先頭1ビットが
%         受信バッファ状態であるため，これを更新する．
% \end{enumerate}
受信バッファに関する情報は受信ディスクリプタが保持している．
具体的には受信バッファのアドレス，および受信バッファ状態を持っている．
NICドライバはパケットの受信処理を行う際，以下の流れで
パケットを取得する．
\begin{enumerate}
    \item 
        NICドライバが受信ディスクリプタ中の受信バッファ状態
        を確認する．
    \item
        受信バッファ状態が受信済み状態ならばNICドライバは受信ディスクリプタ
        から受信バッファのアドレスを取得する．
    \item
        NICドライバが
        取得した受信バッファのアドレスから受信バッファにアクセスし，
        パケットを取得する．
\end{enumerate}
本来はNICがパケットを受信バッファに格納した際にこの受信バッファ状態を変更する．
本機構ではNICを使用せず，デバッグ支援OSがNICの動作を再現するため，
デバッグ支援OSのデバッグ支援機構が共有メモリにパケットを格納した際に
この受信バッファ状態を更新する．
また，デバッグ支援OSが受信ディスクリプタを参照可能にするため，
共有メモリに受信ディスクリプタを配置する必要がある．
そこで，NICドライバの初期化処理中の受信ディスクリプタのアドレスを
決定する処理中で共有メモリのアドレスに変更する．
これにより，共有メモリに受信ディスクリプタが作成される．
\subsection{IPIの送信}
\insertfigure[0.6]{ipi}{ipi}{ipiの送信}
{Awesome Figure 1.}
NICを用いずにデバッグ対象OSに割り込みを発生させるために，
IPIを用いる．
デバッグ支援OSでシステムコールとして定義されている割り込み支援機構が
デバッグ支援OSが占有しているコアにIPIの送信要求を発行し，
これをコアが受け取ることでIPIが送信される．
デバッグ対象OSで登録した割り込みハンドラのベクタ番号を
IPIで指定することで登録した割り込みハンドラが動作する．
IPIを送信する際の流れを図\ref{ipi}に示し，以下で説明する．
\begin{enumerate}
    \item ICRへの情報の書き込み\\
        コアの持つLAPIC(割り込みコントローラ)中のICRというIPI送信用の
        レジスタに，ベクタ番号とLAPIC IDを書き込む．
    \item IPIの送信\\
        LAPIC IDを参照し，このIDを持つコアへIPIを送信する．
    \item 割り込みハンドラの動作\\
        コアがIPIを受信すると，指定したベクタ番号に対応した割り込みハンドラが動作する．
\end{enumerate}
\subsection{共有メモリからパケットを取得する割り込みハンドラ}\label{handler}
割り込みの契機を変更したことにより，NICドライバの割り込みハンドラを変更する必要がある．
このため，IPIにより動作し，共有メモリの受信バッファからパケットを取得し，NICドライバの
ソケットバッファに格納する割り込みハンドラを作成した．
IPIを受信してからNICドライバのソケットバッファにパケットを格納するまでの
流れを以下に示し，説明する．
\begin{enumerate}
    \item IPIの受信\\
        デバッグ対象OSが占有するコア1がIPIを受信する．
    \item 割り込みハンドラの動作\\
        割り込みハンドラが動作し，共有メモリの受信ディスクリプタ内の
        受信バッファ状態を確認する．
    \item パケットの取得\\
        受信バッファ状態が受信済みの状態であれば，受信済みである受信バッファのアドレスの
        受信バッファからパケットを取得し，ソケットバッファに格納する．
\end{enumerate}
作成した割り込みハンドラを利用可能にするには，割り込みハンドラを登録する必要がある．
したがってNICドライバの初期化処理中で作成したハンドラを登録する．
この際，NICドライバのプライベート構造体を参照できるようにするため，
NICドライバの初期化処理の関数内でNICのデバイス構造体を指定して登録する．
\subsection{受信バッファの作成}
Mintの共有メモリを用いてデバッグ支援OSからデバッグ対象OSのNICドライバ
へパケットを受け渡すために，共有メモリにNICの受信バッファを
作成する必要がある．
これを実現するために，NICドライバの初期化処理中の
受信バッファのアドレスを決定する処理内で，共有メモリのアドレスに変更する．
これにより，共有メモリに受信バッファが作成される．
% \subsection{割り込み間隔の調整}
% 割り込みジェネレータにおいて割り込みの間隔をユーザが
% 調整できるような機能を実装する．
% 具体的には連続で割り込みを発生させる際の
% 割り込みの間隔を調整できるようにする．

\chapter{評価}\label{estimaion}
\section{目的}
Mintを用いたNICドライバの割り込みデバッグ支援環境についての評価を行う．
実際のNICを用いた割り込み処理と本研究のデバッグ支援環境の割り込み処理を
比べてどの程度の差があるのかを評価する．
これにより，バグが発生した際と同程度の計算機の状態であることを示す．
\section{項目}
評価の項目について以下に示し，説明する．
\begin{enumerate}
    \item 割り込み間隔の評価\\
        どれだけ短い間隔で連続の割り込みが発生させられるかを評価する．
        具体的には，デバッグ支援OSからデバッグ対象OSへ間隔を調整して
        割り込みを発生させ，どの程度の短さまで正常に割り込みが処理
        されるのかを評価するものである．
    \item CPU負荷の評価\\
        NICを使った実際の割り込み処理と比べて，どの程度のCPU負荷がかかって
        いるのかを評価する．
        具体的には，NICを用いた割り込み処理のCPU負荷を調査し，
        本研究のデバッグ支援環境を用いた割り込み処理のCPUが
        実際の割り込み処理のCPU負荷にどれだけ近付いているかを調査する．
\end{enumerate}
\section{割り込み間隔の評価}
    \subsection{方法}
    未着手
    \subsection{結果と考察}
    未着手
\section{CPU負荷の評価}
    \subsection{方法}
    未着手
    \subsection{結果と考察}
    未着手
\chapter{おわりに}\label{conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{enumerate}
%     \item 本論文の流れを示す．
%     \item Mintを用いたデバッグ支援環境の有用性を示す．
%     \item 本研究ではNICドライバの割り込み処理に，Mintを用いた
%         デバッグ支援環境を適用させたことを示す．
%     \item 残された課題について述べる．

% \end{enumerate}

本論文ではMintを用いたNICドライバの割り込みデバッグ手法について述べた．
まず既存研究である仮想計算機を用いたOSの割り込みデバッグ手法と問題点について述べた．
次にMintとMintを用いた割り込みデバッグ手法について述べた．
次に，Mintを用いたNICドライバの割り込みデバッグ環境の方針，課題，
対処，および必要な機能について述べた．
そして，Mintを用いた割り込みデバッグ環境の実装について述べた．
最後にMintを用いた割り込みデバッグ環境の評価について述べた．

Mintを用いたNICドライバの割り込みデバッグ環境では，実割り込みを発生させられる環境と，
NICを用いずパケットを授受する環境を提供する．
設計の課題として，割り込み間隔と回数の調整，パケットの作成，パケットの格納，受信バッファ状態の
更新，割り込み契機の変更，割り込みハンドラの作成，および受信バッファの作成を示した．
これらの対処として，割り込みジェネレータの作成，デバッグ支援機構の作成，IPIの送信，および
NICドライバの改変を示した．

本研究ではNICのパケット受信処理に対するNICドライバの割り込み処理をデバッグ対象とした．
これを実現する機能として，割り込みジェネレータ，パケットの作成，受信バッファへのパケットの格納，
受信バッファ状態の更新，IPIの送信，割り込みハンドラ，および受信バッファの作成について示した．
これらの機能の内，割り込みジェネレータはデバッグ支援OS上で動作するAPとして実装し，割り込み情報を
指定してデバッグ支援機構に通知することを示した．パケットの作成，受信バッファへの
パケットの格納，受信バッファ状態の更新，およびIPIの送信についてはデバッグ支援機構の機能として
動作するもので，システムコールとして実装することを示した．
割り込みハンドラ，および受信バッファの作成についてはNICドライバを改変し，実現することを示した．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acknowledgment\label{acknowledgement} % 謝辞
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

(一例)
本研究を進めるにあたり，懇切丁寧なご指導をしていただきました
乃村能成准教授に心より感謝の意を表します．
また，研究活動において，数々のご指導やご助言を与えていただいた
谷口秀夫教授，山内利宏准教授に心から感謝申し上げます．
また，日頃の研究活動において，お世話になりました研究室の
皆様に感謝いたします．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 参考文献

% bibtex を使って埋める
% https://github.com/nomlab/nompedia/wiki/tex--index#user-content-pbibtex%25E3%2581%25AE%25E4%25BD%25BF%25E3%2581%2584%25E6%2596%25B9

% \bibliographystyle{tipsj}    % 情報処理学会形式(旧)
\bibliographystyle{ipsjunsrt} % 情報処理学会形式(新)
\bibliography{mybibdata}


\end{document}
