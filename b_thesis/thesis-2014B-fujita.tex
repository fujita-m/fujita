\documentclass[tanilab-enum]{graduate}
\usepackage{makeidx}
\usepackage[dvipdfmx]{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% sty/ にある研究室独自のスタイルファイル

\usepackage{jtygm}  % フォントに関する余計な警告を消す
\usepackage{nutils} % insertfigure, figef, tabref マクロ

\def\figdir{./figs} % 図のディレクトリ
\def\figext{pdf}    % 図のファイルの拡張子

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 学部用の所属設定

\major{岡山大学工学部 情報系学科}
\department{岡山大学工学部}
\subdepart{情報系学科}
\booktype{特別研究報告書}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 修士用の所属設定

%\major{岡山大学大学院 自然科学研究科 電子情報システム工学専攻}
%\department{岡山大学大学院 自然科学研究科}
%\subdepart{電子情報システム工学専攻}
%\booktype{修士論文}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% タイトル，索引

\title{Mintオペレーティングシステムを用いたNICドライバの割り込みデバッグ手法の実現}
\author{藤田 将輝}
\date{平成27年2月6日}

\makeindex

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\abstract{要約}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  OSのデバッグ手法としてVMを用いたものがある．これはVM上で2つのOSを走
行させ，一方のOSから他方のOSへ任意のタイミングで割り込みを発生させるこ
とにより，バグを再現し，デバッグを支援するものである．しかし，VMを用い
たデバッグ手法では，VMとハイパーバイザ間の処理の遷移に伴う処理負荷が発
生する．このため，一定間隔で連続で発生する割り込みや短い間隔で
連続で発生する割り込みのバグの
ように処理負荷が影響する割り込み処理のデバッグが困難である．

そこで，Mintを用いたOSのデバッグ手法が提案されている．
Mintは1台の計算機上で複数のOSが論理分割された計算機資源を直接操作できる．
また，割り込み処理のデバッグは困難であるが，特に非同期な割り込み処理の
デバッグは非常に困難である．
この非同期な割り込み処理が頻繁に発生するのがNICを用いた通信である．
本研究では，提案手法を用いて，NICにおける割り込みを任意に挿入できる
環境を実現する．具体的には，
デバッグを支援するOSからNICドライバが割り込み処理をするパケットを
デバッグを支援するOSとデバッグ対象のOSが共有しているメモリに格納し，
割り込み元OSが占有しているコアから割り込み先のOSが占有して
いるコアへIPIを送信することにより，割り込みハンドラが動作し，NICドライ
バが共有メモリからパケットを取得することで割り込み処理を発生させるもの
である．これにより，NICドライバの割り込みにより発生するバグを再現し，
デバッグを支援することができる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableandlists% 目次，図表目次
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{はじめに}\label{chap:introduction}
近年，OSの多機能化に伴って，OSのデバッグが重要視されている．
OSのデバッグ，特に割り込み処理に関するデバッグは非同期的な
処理であるため，デバッグが困難になっている．
このデバッグを支援する方法として，仮想計算機を用いたものがある．
仮想計算機を用いて，デバッグを支援するOS(以下，デバッグ支援OS)と
デバッグ対象のOS(以下，デバッグ対象OS)の2つのOSを
動作させ，デバッグ支援OSがデバッグ対象OSへ割り込みを挿入させたり，
デバッグ支援OSがデバッグ対象OSの動作を再現したりすることで，
バグを再現し，デバッグを支援する．
しかし，仮想計算機を用いると，仮想計算機とハイパーバイザ間の
処理の遷移に伴う処理負荷が存在するため，一定間隔で発生する
割り込みや，短い間隔で発生するバグのように，処理負荷が影響する
割り込み処理のデバッグが困難である．

そこで，Multiple Independent operating systems with New Technology(以下，Mint)\cite{senzaki}
を用いたデバッグ手法が提案されている．
Mintは仮想化を用いずに複数のLinuxを動作できるOSである．
このため，Mintを用いてデバッグ支援環境を構築すると，
ハイパーバイザが存在しないため，処理の遷移に伴う処理負荷も
同様に存在しなくなる．
これにより，一定間隔で発生する割り込み割り込みや短い間隔で発生する
バグのデバッグが可能になる．

本論文では，非同期的な割り込みが頻繁に発生するNICドライバを対象とした
Mintのデバッグ支援環境を構築することで，
NICドライバの割り込み処理のデバッグを支援する環境について述べる．
2章では仮想計算機を用いた既存研究のデバッグ手法の概要，処理流れ，
および問題点について述べる．
3章ではMintとMintを用いたデバッグ支援環境の概要，および処理流れに
ついて述べる．
4章では，Mintを用いたNICドライバの割り込みデバッグ支援環境の設計について述べる．
5章ではMintを用いたNICドライバの割り込みデバッグ支援環境の実装について
述べる．
6章ではNICドライバの割り込みデバッグ支援環境の評価について述べる．
\chapter{関連研究}\label{chap:kanren}
\section{仮想計算機を用いたデバッグ支援機構}
OSのデバッグを支援する環境の既存研究として仮想計算機を用いたものがある．
仮想計算機を用いたデバッグ支援環境は大きく分けて2つある．
割り込み挿入法とロギング/リプレイ手法である．
これらについて\ref{kasougaiyou}節で説明する．
\section{概要と処理流れ}\label{kasougaiyou}
    \subsection{割り込み挿入法の概要}
    割り込み挿入法\cite{miyahara}はハイパーバイザ上で
    動作するデバッグ支援OSと
    デバッグ対象OSによって構成される．
    プログラマがデバッグ対象OSの割り込みを挿入したいコード位置で
    ハイパーコールを挿入する．
    デバッグ対象OSの走行時に，ハイパーコールを挿入した位置で
    処理が遷移し，デバッグ支援OSで割り込みに必要なデータを用意した後，
    デバッグ対象OSに割り込みを発生させ，バグを再現し，デバッグを支援する．
   % \subsubsection{(処理流れ)}
    \subsection{割り込み挿入法の処理流れ}
    \insertfigure[0.8]{sonyu}{sonyu}{割り込み挿入法の処理流れ}
    {Awesome Figure 1.}

    割り込み挿入法ではユーザが割り込みを発生させたいコード位置で
    ハイパーコールを挿入する．割り込みは挿入したコード位置で発生する．
    また，割り込みはVirtual Machine Control Structure(以下，VMCS)
    と呼ばれるデータ構造の値を書き換えることで発生する．
    デバッグ対象OSとデバッグ支援OSはハイパーバイザ内のデバッグ支援機構
    でデータの授受をする．
    割り込み挿入法の処理流れについて図\ref{sonyu}に示し，
    以下で説明する．
    \begin{enumerate}
        \item 割り込み発生要求\\
            デバッグ対象OSに挿入したハイパーコールにより，デバッグ対象OS
            がハイパーバイザのデバッグ支援機構へ割り込み発生要求を行う．
            その後，デバッグ対象OSの処理を中断し，ハイパーバイザへ処理が
            遷移する．
        \item データ生成要求\\
            ハイパーバイザのデバッグ支援機構がデバッグ支援OSのデバッグ支援機構
            へ割り込みに必要なデータの生成要求を行う．
            割り込みに必要なデータとは，パケットやキーコードである．
        \item データの生成\\
            デバッグ支援OSのデバッグ支援機構が割り込みに必要なデータを生成する．
        \item データ生成完了通知\\
            デバッグ支援OSのデバッグ支援機構がハイパーバイザのデバッグ支援機構
            へデータの生成完了を通知する．
        \item VMCSの変更\\
            ハイパーバイザのデバッグ支援機構がVMCSの内容を変更する．
            これにより，処理がハイパーバイザからデバッグ対象OSへ処理が遷移するとき
            割り込みが発生する．
        \item 割り込み発生\\
            デバッグ対象OSへ処理が遷移し，割り込みが発生する．
    \end{enumerate}
    \subsection{ロギング/リプレイ手法の概要}
    ロギング/リプレイ手法はハイパーバイザまたはハードウェア上で
    動作するホストOSと呼ばれるOS上で動作する
    デバッグ対象OSにより構成される．
    この手法はデバッグ対象OSがバグを起こすまでの流れを保存し，
    再現することで，デバッグを支援する．
    ここでロギングとはOSの動作の流れを保存することで，
    リプレイとは保存した流れを再現することである．
    また，処理の流れを再現するための情報として，以下のような情報
    がある．これらの情報を以下，再現情報と呼ぶ．
    \begin{enumerate}
        \item 割り込みの種類，割り込み発生アドレス，および分岐命令を経由した回数\\
            割り込みの種類とこの割り込みが発生したアドレス，および分岐命令を経由した
            回数である．
        \item 割り込み発生時に使用するデータ\\
            キーコードや，パケットなどのような割り込み処理で扱うデータである．
    \end{enumerate}
    ロギング/リプレイ手法を用いた関連研究としてTTVM\cite{samuel}，
    およびSesta\cite{kawasaki}がある．
    TTVMは再現情報に加え，デバッグ対象OS側の仮想計算機の状態を保存する．
    Sestaはロギングを行うOSの処理を追うようにしてリプレイを行うOSを走行させる．

    \subsection{ロギングの処理流れ}
    \insertfigure[0.8]{loging}{loging}{ロギングの処理流れ}
    {Awesome Figure 1.}

    ロギングの処理流れについて図\ref{loging}に示し，
    以下で説明する．
    \begin{enumerate}
        \item 割り込みの発生\\
            デバッグ対象OSに割り込みが発生すると，
            処理を中断し，ハイパーバイザに処理が遷移する．
        \item 再現情報の格納\\
            ハイパーバイザのデバッグ支援機構が再現情報をメモリに格納する．
        \item 割り込み処理の開始\\
            ハイパーバイザからデバッグ対象OSへ処理が遷移し，
            デバッグ対象OSが中断していた割り込み処理を再開する．
    \end{enumerate}
    \subsection{リプレイの処理流れ}
    \insertfigure[0.8]{replay}{replay}{リプレイの処理流れ}
    {Awesome Figure 1.} 
    リプレイの処理流れについて図\ref{replay}に示し，
    以下で説明する．
            \begin{enumerate}
                \item 再現情報の取得\\
                    ハイパーバイザのデバッグ支援機構がメモリから再現情報を取得する．
                \item 割り込み発生アドレスまでの処理の実行\\
                    取得した再現情報よりデバッグ対象OSが割り込みが発生するアドレスまで
                    命令を実行する．
                \item 分岐回数の比較\\
                    ハイパーバイザのデバッグ支援機構が再現情報の分岐回数と，現在の
                    デバッグ対象OSの分岐回数を比較する．
                \item 割り込みの発生\\
                    デバッグ対象OSへ割り込みが発生する．
            \end{enumerate}
        
\section{問題点}
割り込み挿入法の問題点について以下で説明する．
\begin{enumerate}
    \item 実計算機上で発生する間隔での複数割り込みの発生が困難\\
        割り込み挿入法では割り込みを発生させる際，OSのコードの任意の位置にハイパーコールを
        挿入することで割り込みを発生させる．コードが実行されるタイミングはOSの処理速度に
        依存する．このため，CPUへ発生する間隔で複数の割り込みを発生させようとした際に，
        この間隔を調整するのはハイパーコールの間隔を調整することで行うが，
        ユーザがハイパーコールの間隔を調整することでCPUへ発生する間隔を
        調整することは非常困難である．
        つまり，実計算機上で発生する間隔での複数の割り込み(以下，実割り込み)
        を発生させることが困難である．
\end{enumerate}
また，ロギング/リプレイ手法の問題点について以下で説明する．
\begin{enumerate}
\setcounter{enumi}{1}
    \item 任意のタイミングでの割り込み発生が困難\\
        ロギング/リプレイ手法は，ロギング時に発生した割り込みに対する処理をリプレイ時
        に確認できる．しかし，任意のタイミングで割り込みを発生させるためには，再現情
        報として割り込みを発生させるアドレスと分岐回数をプログラマが用意しなければな
        らない．これらの指定が困難であるため，任意のタイミングで割り込みを発生させる
        ことが困難である．
    \item 実割り込みの発生が困難\\
        ロギング/リプレイ手法は，ロギングにおけるデバッグ対象OS とハイパーバイザの間
        の処理の遷移や再現情報の格納による処理負荷が発生する．このため，実割り込みがロ
        ギング中に発生しないと考えられる．ロギング中に実割り込みが発生しない場合，実
        割り込みを再現するための再現情報を保存できない．このため，実割り込みの発生が
        困難である．
\end{enumerate}
これらの問題点から，割り込み処理のデバッグには，デバッグ対象OSがデバッグ支援機構の
処理負荷の影響を受けない環境が必要である．
\chapter{Mintオペレーティングシステム}\label{chap:Mint}
\section{Mintの設計方針}
Mintとは1台の計算機上で仮想化を用いずに計算機資源を分割することによって
複数のLinuxを動作させる方式である．
Mintの設計方針として以下の2つが挙げられる．
\begin{enumerate}
    \item 全てのLinuxが相互に処理負荷の影響を抑制
    \item 全てのLinuxが入出力性能を十分に利用可能
\end{enumerate}
\section{Mintの構成}
\insertfigure[0.8]{mintkousei}{mintkousei}{Mintの構成}
{Awesome Figure 1.}

Mintでは，1台の計算機上でCPU，メモリ，およびデバイスを分割し，各OSが
占有する．Mintの構成例を図\ref{mintkousei}に示し，説明する．
Mintでは，最初に起動するOSをOSノード0とし，起動順にOSノード1，OSノード2，
．．．とする．
\begin{enumerate}
    \item CPU\\
        コア単位で分割し，各OS ノードがコアを1 つ以上占有する．
    \item メモリ
        空間分割し，各OS ノードが分割領域を占有する．
    \item デバイス\\
        デバイス単位で分割し，各OS ノードが指定されたデバイスを占有する．
\end{enumerate}
\section{Mintを用いたデバッグ支援環境}
    \subsection{概要}
     \ref{chap:kanren}章で述べたように，割り込み処理のデバッグにはデバッグ対象OS
    がデバッグ支援機構の処理負荷の影響を受けない環境が必要である．
    そこで，仮想化を用いずに複数のLinuxを動作できるMintを用いた
    デバッグ支援環境が提案されている．Mintを用いることで，
    実割り込みの発生が可能になる．また，任意のタイミングでの割り込み
    発生も可能になる．
   
    提案されているMint用いたデバッグ支援環境の概要について図\ref{mintdebugkousei}に示し，
    説明する．
    Mintを用いたデバッグ支援環境はOSノード0としてデバッグ支援OSが，
    OSノード1としてデバッグ対象OSが動作する．デバッグ支援OSにはデバッグ支援機構があり，
    デバッグ対象OSへ割り込みを発生させる．また，割り込みジェネレータを
    デバッグ支援OSのアプリケーションとして実装している．
    これらの割り込みジェネレータ，デバッグ支援機構，デバッグ支援OS，
    およびデバッグ対象OSについて以下で説明する．
    \begin{enumerate}
        \item 割り込みジェネレータ\\
            プログラマが割り込み情報を指定する際に利用するアプリケーション
            である．なお，割り込み情報とは割り込みの種類，発生間隔，
            および発生回数を合わせた情報である．
        \item デバッグ支援機構\\
            割り込みジェネレータから通知される割り込み情報をもとに，
            デバッグ対象OS へInter-Processor Interrupt(以下，IPI)を送信する機構である．
        \item デバッグ支援OS\\
            デバッグ支援機構を実装して走行するOS である．
            ここでは，コア0 を占有して走行する．
        \item デバッグ対象OS\\
            デバッグ対象となるOS である．ここでは，コア1 を占有して
            走行する．
    \end{enumerate}
    \subsection{Mintを用いたデバッグ支援環境の処理流れ}
    \insertfigure[0.8]{mintdebugnagare}{mintdebugnagare}{Mintを用いたデバッグ支援環境の処理流れ}
    {Awesome Figure 1.}

    Mintを用いたデバッグ支援環境の処理流れを図\ref{mintdebugnagare}に示し，以下で
    説明する．
    \begin{enumerate}
        \item 割り込み情報の指定\\
            デバッグ支援OS上で動作するAPを用いてプログラマが
            割り込み情報を指定する．
        \item 割り込み情報の通知\\
            割り込みジェネレータがシステムコールを用いて
            割り込み情報をデバッグ支援OSのデバッグ支援環境に通知する．
        \item IPIの送信要求\\
            デバッグ支援機構がコア0へIPIの送信要求を行う．
        \item IPIの送信\\
            コア0がIPIの送信要求を受けると，コア1へIPIを送信する．
        \item 割り込み処理の開始\\
            コア1がIPIを受信すると割り込み処理が開始する．
    \end{enumerate}
\section{MintにおけるLinux改変によるバグの影響}
Mintでは1台の計算機上で複数のLinuxを動作させるため，各Linuxに
改変を加える\cite{kitagawa}．
この際の改変は各Linuxの起動時に認識するCPU，メモリ，およびデバイスを調停するための
ものであり，割り込み処理に変更は加えていない．したがって，MintにおけるLinux改変に
おけるバグの影響はないと考えられる．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{NICドライバの割り込みデバッグ環境の設計}\label{chap:plan}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{目的}
% \begin{enumerate}
%     \item 前章で述べたMintを用いたデバッグ支援環境をNICドライバの
%         デバッグに適用させる．
%     \item NICドライバにはバグの原因となりやすい非同期な割り込みが
%         頻繁に発生するためである．
% \end{enumerate}
割り込み処理におけるバグの原因として，非同期な割り込みがある．
非同期な割り込みとは，割り込み先と割り込み元でタイミングを合わせないで
発生する割り込みのことである．
この非同期な割り込みが頻繁に発生するのがNICドライバである．
NICドライバにMintを用いた割り込みデバッグ支援環境を構築し，
非同期な割り込みを再現することでNICドライバのデバッグを支援する．
また，本研究におけるデバッグ支援環境はNICドライバの受信処理に関する
デバッグを行うものである．
\section{NICドライバのパケット受信の流れ}
\insertfigure[0.8]{nicnagare}{nicnagare}{NICドライバのパケット受信処理流れ}
{Awesome Figure 1.}

NICがパケットを受信してからNICドライバで割り込み処理が
発生するまでの流れを図\ref{nicnagare}に示し，以下で説明する．
\begin{enumerate}
    \item 受信バッファアドレスの取得\\
        NICが受信ディスクリプタから受信バッファのアドレスを取得する．
    \item 受信バッファへのパケットの格納\\
        NICが受信バッファのアドレスをもとに，
        受信バッファへパケットを格納する．
    \item 受信バッファ状態の更新\\
        NICが受信ディスクリプタ中の受信バッファ状態を更新し，
        受信済み状態にする．
    \item パケット受信割り込みの発生\\
        NICがNICドライバに割り込みを発生する．
    \item 受信バッファの特定\\
        NICドライバが受信ディスクリプタの受信バッファ状態を確認し，受信バッファを特定する．
    \item ソケットバッファへのパケットの格納\\
        NICドライバが受信バッファからソケットバッファへパケットを取得し，格納する．
\end{enumerate}

\section{NICドライバのデバッグ支援環境の構成}
\insertfigure[0.6]{nicmintkousei}{nicmintkousei}{NICドライバのデバッグ支援環境の概要}
{Awesome Figure 1.}
NICドライバのデバッグ支援環境の構成を図\ref{nicmintkousei}に示す．
NICドライバのデバッグ支援環境はデバッグ支援OS，デバッグ対象OS，
共有メモリ，NICドライバ，デバッグ支援機構，CPU，およびアプリケーションによって
構成される．
それぞれについて以下で説明する．
\begin{enumerate}
    \item デバッグ支援OS\\
        NICドライバのデバッグを支援するOSである．
        このOSはNICの動作を擬似する．
    \item デバッグ対象OS\\
        デバッグの対象となるOSである．
        本研究ではこのOSのNICドライバの受信処理のデバッグを
        対象としている．
    \item 共有メモリ\\
        Mintの共有メモリである．
        これを用いてデバッグ支援OSからデバッグ対象OSのNICドライバへ
        パケットを受け渡す．
    \item NICドライバ\\
        デバッグ対象OS内で動作している．
        受信バッファを共有メモリとみなすように改変されている．
        また，割り込みの契機としてIPIを用いる．
    \item デバッグ支援機構\\
        ユーザが指定した情報に基づいてパケットを作成し，共有メモリに配置する．
        また，コア0へIPIの送信要求を発信する．
    \item CPU\\
        コアを分割してコア0をデバッグ支援OSに，コア1をデバッグ対象OSに占有させている．
    \item アプリケーション\\
        ユーザがパケットの種類，割り込みの発生間隔を指定する．
        この情報からデバッグ支援機構によりパケットが生成される．
\end{enumerate}

\section{設計方針}
Mintを用いたNICドライバの割り込みデバッグ支援機構の設計方針を述べる．

まず，デバッグ支援OSがデバッグ対象OSのNICドライバへ割り込みを発生させられる
環境を構築する．
従来の仮想計算機を用いたデバッグ支援環境では，ハイパーバイザへの
処理遷移のため実割り込みが困難である．
そこで本研究におけるNICドライバの割り込みデバッグ支援環境では
実割り込みの再現を可能にする．

次に，NICドライバの割り込み処理のデバッグを対象とするため，
ハードウェア(NIC)のバグは考慮しない．
したがって，NICを用いずに割り込みデバッグ支援環境を構築する．
NICはパケットを受信バッファに格納し，受信ディスクリプタ中の
受信バッファ状態を更新する機能を持っている．
NICを用いずに割り込みデバッグ支援環境を構築するため，
NICの機能を再現するものが必要になる．
そこでNICの機能を再現するものがデバッグ支援OSである．
デバッグ支援OSがNICの機能を再現することでNICを用いずに
NICドライバの割り込みデバッグ支援環境を構築する．

最後に，NICの動作をデバッグ支援OSが再現するため，
Mint上で動作する2つのOS間でパケットの受け渡しが必要になる．
これを可能にするため，両OS間の共有メモリを用いる．
共有メモリ上にNICの受信バッファと受信ディスクリプタを
配置することにより，デバッグ支援OSからデバッグ対象OSの
NICドライバへパケットを受け渡す．

以上の方針を以下にまとめる．
\begin{description}
    \item[(方針1)]実割り込みの再現
    \item[(方針2)]NICの動作をデバッグ支援OSが再現
    \item[(方針3)]共有メモリを用いてのパケットの受け渡し

\end{description}


\section{設計にあたっての課題}
% 設計にあたっての課題を以下に示す．
% \begin{description}
%     \item[(課題1)] 1台の計算機上で動作する2つのLinux間でのパケットの授受
%     \item[(課題2)] NICを用いないため，割り込みの契機を変更．
%     \item[(課題3)] 割り込みハンドラとして，受信バッファ相当のものからパケットを取得するもの
%         を登録
%     \item[(課題4)] 割り込みの間隔の調整
% \end{description}
それぞれの設計についての課題について以下に示し，説明する．
\begin{description}
    \item[課題1]割り込み間隔，回数の調整\\
        方針1の課題として，実割り込みを再現するためには割り込みの間隔を調整し，連続で
        割り込みを発生させる必要がある．割り込みの間隔と回数を指定できる環境が必要．
    \item[課題2]パケットの作成\\
        方針2の課題として，NICドライバに受け渡すためのパケットを作成する必要がある．
    \item[(課題3)]パケットの格納\\
        方針2の課題として，NICの機能のパケットを受信バッファに格納する機能を再現するために，
        デバッグ支援OSが受信バッファにパケットを格納する機能が必要である．
    \item[(課題4)]受信バッファ状態の更新\\
        方針2の課題として，NICの機能の受信ディスクリプタ中の受信バッファ状態を受信済み状態に
        書き換える機能を再現するために，デバッグ支援OSが受信バッファ状態を書き換える機能が
        必要である．
    \item[(課題5)]割り込み契機の変更\\
        方針2の課題として，NICの機能のNICドライバに割り込みを発生させる機能を再現するために，
        割り込みの契機を変更する必要がある．
    \item[(課題6)]割り込みハンドラの作成\\
        割り込み契機の変更に伴って，NICドライバの割り込みハンドラを変更する必要がある．
        変更した割り込み契機により動作する割り込みハンドラが必要になる．
    \item[(課題7)]受信バッファの作成\\
        方針3の課題として，デバッグ支援OSが共有メモリにパケットを配置し，
        デバッグ対象OSが共有メモリからパケットを取得するために，共有メモリに
        NICの受信バッファを作成する必要がある．
\end{description}

\section{課題への対処}
課題への対処を以下に示し，説明する．
% \begin{description}
%     \item[(対処1)]課題1への対処としてMintの共有メモリを用いての，
%         パケットの授受
%     \item[(対処2)]課題2への対処として，割り込みはIPIを使用
%     \item[(対処3)]課題3への対処として，NICドライバを改変することにより，
%         共有メモリからパケットを取得し，処理をする割り込みハンドラを
%         作成し，登録
%     \item[(対処4)]課題4の対処として，ユーザから割り込みの間隔を指定可能
% \end{description}
\begin{description}
    \item[(対処1)]割り込みジェネレータによる指定(課題1)\\
        割り込み間隔と回数をユーザが指定できるようにするため，
        デバッグ支援OS上にこれらの情報が指定できる割り込みジェネレータを
        APとして実装する．指定した間隔で指定した回数割り込みを発生させる
        システムコールを発行する．
    \item[(対処2)]システムコール内でのパケットの作成(課題2)\\
        NICドライバで処理されるパケットは，パケット中のデータ部分のみ
        である．そこで適当なデータを用意することでNICドライバが処理をする
        パケットとする．
    \item[(対処3)]システムコールによるパケットの格納\\
        NICの受信バッファへのパケットの格納はデバッグ支援OSのシステムコールに
        より実現する．対処2により作成されたパケットを共有メモリ上に作成した
        受信バッファに配置する．
    \item[(対処4)]システムコールによる受信バッファ状態の変更\\
        受信バッファ状態をデバッグ支援OSで書き換えるために，
        受信ディスクリプタを共有メモリに配置し，デバッグ支援OSとデバッグ対象OS
        両OSで参照可能にする．
        これにより，デバッグ支援OSが受信ディスクリプタ中の受信バッファ状態を
        書き換え可能になる．
    \item[(対処5)]割り込み契機としてIPIを使用\\
        NICの受信割り込みの再現として，コア間割り込みであるIPIを使用する．
        IPIは仮想計算機における割り込みのようにハイパーバイザとOS間の処理の
        遷移は存在しないため，実割り込みの再現が可能になる．
    \item[(対処6)]IPIにより動作し，共有メモリからパケットを取得する割り込みハンドラ\\
        割り込みの契機をIPIに変更したことにより，IPIにより動作するNICドライバの
        割り込みハンドラを作成する．この割り込みハンドラはデバッグ対象OSが
        占有するコアがIPIを受信すると
        動作し，共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する機能を持つ．
        この割り込みハンドラをNICドライバの初期化処理の中で登録し，使用可能にする．
    \item[(対処7)]共有メモリへの受信バッファの作成\\
        共有メモリを用いてデバッグ支援OSとデバッグ対象OSのNICドライバ
        間でパケットを受け渡すために，NICの受信バッファを共有メモリに作成する
        必要がある．このために，NICドライバの初期化処理内で，受信バッファの
        アドレスを変更し，共有メモリのアドレスにする．

\end{description}
\section{対処を実現するために必要な機能}
対処を実現するために必要な機能を以下に示し，説明する．
% \begin{enumerate}
%     \item パケットの共有メモリへの格納\\
%         対処1の実現として，デバッグ支援OS内のデバッグ支援機構において
%         パケットを共有メモリに格納できるようにする．
%     \item IPIの送信\\
%         対処2の実現として，IPIを送信し割り込みを発生させる機能を実装する．
%     \item 受信バッファ状態の更新\\
%         対処3の実現として受信ディスクリプタ内の，
%         受信バッファがパケットを受信ているか否かの情報を持つ
%         受信バッファ状態を更新し，受信済みの状態にする機能を実装する．
%     \item 共有メモリからパケットを取得する割り込みハンドラの作成\\
%         対処3の実現として，共有メモリからパケットを取得する割り込みハンドラを
%         作成する．
%     \item 割り込みジェネレータの作成\\
%         対処4を実現するために，ユーザが割り込み情報を指定するAPを作成する．
%     \item 割り込みハンドラの登録\\
%         対処4の実現として，NICドライバ内で割り込みハンドラを登録し，IPIにより
%         動作できるようにする．
%     \item 割り込みジェネレータにおいての割り込み間隔の調整\\
%         対処4を実現するために，割り込みジェネレータにおいてユーザが割り込みの間隔を
%         指定できるようにする．
% \end{enumerate}
\begin{description}
    \item[(機能1)]割り込みジェネレータ\\
        対処1の実現として，デバッグ支援OS上で動作するAPを作成し，
        このAPで割り込みの間隔，割り込みの回数を指定する機能を実装する．
        これをシステムコールにより，デバッグ支援機構に通知する．
    \item[(機能2)]パケットの作成\\
        対処2の実現として，デバッグ支援OS内にデバッグ支援機構を
        システムコールとして実装し，その処理においてパケットのデータを
        定義する機能を実装する．
    \item[(機能3)]受信バッファへのパケットの格納\\
        対処3の実現として，デバッグ支援機構の処理において機能2で
        作成したパケットを共有メモリに作成された受信バッファに格納する
        機能を実装する．
    \item[(機能4)]受信バッファ状態の更新\\
        対処4の実現として，デバッグ支援機構の処理において共有メモリに配置されている
        受信ディスクリプタを取得し，その受信ディスクリプタ中の受信バッファ状態を
        書き換え，受信済み状態にする機能を実装する．
    \item[(機能5)]IPIの送信\\
        対処5の実現として，デバッグ支援機構が，デバッグ支援OSが占有している
        コア0にコア0からデバッグ対象OSが占有しているコア1へIPIの送信
        要求を発行する機能を実装する．
    \item[(機能6)]割り込みハンドラ\\
        対処6の実現として，デバッグ対象OSで動作するNICドライバにおいて
        IPIにより動作し，共有メモリに作成された受信バッファからパケット
        を取得し，ソケットバッファに格納する機能を持つ割り込みハンドラを実装する．
        また，NICドライバの初期化処理中でこの割り込みハンドラを登録する．
    \item[(機能7)]受信バッファの作成\\
        対処7の実現として，デバッグ対象OSで動作するNICドライバの初期化処理中で
        受信バッファのアドレスを決定する際に，このアドレスを共有メモリのアドレス
        に変更する．
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{実装}\label{chap:implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NICドライバのデバッグ支援環境の処理流れ}
\insertfigure[0.8]{nicmintnagare}{nicmintnagare}{NICドライバのデバッグ支援環境の処理流れ}
{Awesome Figure 1.}

Mintを用いたNICドライバの割り込みデバッグ支援環境の処理流れを
図\ref{nicmintnagare}に示し，以下で説明する．
\begin{enumerate}
    \item 割り込み情報の指定\\
        割り込みジェネレータでユーザが割り込み情報を指定する．
    \item 割り込み情報の通知\\
        デバッグ支援OSのデバッグ支援機構に指定した割り込み情報をシステムコールにより通知する．
    \item パケットの作成\\
        デバッグ支援機構が割り込み情報からパケットを作成する．
    \item 受信バッファへのパケットの格納\\
        デバッグ支援機構が共有メモリの受信バッファへパケットを格納する．
    \item 受信バッファ状態の更新\\
        デバッグ支援機構が共有メモリの受信ディスクリプタの受信バッファ状態
        を更新する．
    \item 割り込み発生要求\\
        デバッグ支援機構がコア0へIPI送信要求を行う．
    \item IPIの送信\\
        コア0がコア1へIPIを送信する．
    \item 割り込み処理の開始\\
        コア1がIPIを受信すると，
        デバッグ対象OSの割り込みハンドラが動作する．
    \item 受信バッファ状態の確認\\
        NICドライバが共有メモリの受信ディスクリプタ中の
        受信バッファ状態を確認する．
    \item ソケットバッファへのパケットの格納\\
        NICドライバが共有メモリの受信バッファからパケットを取得し，
        ソケットバッファに格納する．
\end{enumerate}

\section{必要な機能の実現}

\subsection{割り込みジェネレータ}
割り込みジェネレータはデバッグ支援OS上で動作するAPとして実装する．
割り込みジェネレータではパケットを作成する際の情報を指定する．
具体的には，割り込みの種類，割り込みの間隔，および回数である．
これらの情報をシステムコールとして実装するデバッグ支援機構の
引数として通知する．

\subsection{パケットの作成}\label{packet}
パケットの作成は，デバッグ支援機構の機能として実装する．
NICドライバはパケットのデータ部をソケットバッファに格納し，
ソケットバッファを上の層に送ることで割り込み処理を終了する．
したがって，データ部をパケットとして用意できればよい．
そこで，適当なデータを定義し，パケットとしている．

\subsection{受信バッファへのパケットの格納}
Mintの共有メモリを利用してパケットの受け渡しを実現する．
デバッグ支援機構において，\ref{packet}節で
作成されたパケットを共有メモリの受信バッファに格納する．
共有メモリへのパケットの格納はシステムコールにより定義されたデバッグ支援機構
によって実現する．
NICドライバの受信バッファはリングバッファとなっているため，
デバッグ支援機構において擬似的な送信ディスクリプタを用意し，
これを用いてリングバッファに対応する．

\subsection{受信バッファ状態の更新}
% \begin{enumerate}
%     \item 受信バッファ状態(受信バッファにパケットが格納されているか
%         否かの状態)を更新し，受信済み状態にする．
%     \item 具体的には，受信ディスクリプタの先頭1ビットが
%         受信バッファ状態であるため，これを更新する．
% \end{enumerate}
受信バッファに関する情報は受信ディスクリプタが保持している．
具体的には受信バッファのアドレス，受信バッファにパケットが
格納されているか否かの状態(受信バッファ状態)を持っている．
NICドライバはパケットの受信処理を行う際，まず受信ディスクリプタ中の
受信バッファ状態を確認し，受信済み状態ならば受信ディスクリプタから
受信バッファのアドレスを取得する．そして，このアドレスから受信バッファに
アクセスし，パケットを取得する．
本来はNICがパケットを受信バッファに格納した際にこの受信バッファ状態を変更する．
本機構ではNICを使用せず，デバッグ支援OSがNICの動作を再現するため，
デバッグ支援OSのデバッグ支援機構が共有メモリにパケットを格納した際に
この受信バッファ状態を更新する．
\subsection{IPIの送信}
\insertfigure[0.6]{ipi}{ipi}{ipiの送信}
{Awesome Figure 1.}
NICを用いずにデバッグ対象OSに割り込みを発生させるために，
IPIを用いる．
デバッグ支援OSでシステムコールとして定義されている割り込み支援機構が
デバッグ支援OSが占有しているコアにIPIの送信要求を発行し，
これをコアが受け取ることでIPIが送信される．
デバッグ対象OSで登録した割り込みハンドラのベクタ番号を
IPIで指定することで登録した割り込みハンドラが動作する．
IPIを送信する際の流れを図\ref{ipi}に示し，以下で説明する．
\begin{enumerate}
    \item ICRへの情報の書き込み\\
        コアの持つLAPIC(割り込みコントローラ)中のICRというIPI送信用の
        レジスタに，ベクタ番号とLAPIC IDを書き込む．
    \item IPIの送信\\
        LAPIC IDを参照し，このIDを持つコアへIPIを送信する．
    \item 割り込みハンドラの動作\\
        コアがIPIを受信すると，指定したベクタ番号に対応した割り込みハンドラが動作する．
\end{enumerate}
\subsection{共有メモリからパケットを取得する割り込みハンドラ}\label{handler}
割り込みの契機を変更したことにより，NICドライバの割り込みハンドラを変更する必要がある．
このため，IPIにより動作し，共有メモリの受信バッファからパケットを取得し，NICドライバの
ソケットバッファに格納する割り込みハンドラを作成した．
IPIを受信してからNICドライバのソケットバッファにパケットを格納するまでの
流れを以下に示し，説明する．
\begin{enumerate}
    \item IPIの受信\\
        デバッグ対象OSが占有するコア1がIPIを受信する．
    \item 割り込みハンドラの動作\\
        割り込みハンドラが動作し，共有メモリの受信ディスクリプタ内の
        受信バッファ状態を確認する．
    \item パケットの取得\\
        受信バッファ状態が受信済みの状態であれば，受信済みである受信バッファのアドレスの
        受信バッファからパケットを取得し，ソケットバッファに格納する．
\end{enumerate}
作成した割り込みハンドラを利用可能にするには，OS割り込み割り込みハンドラを登録する必要がある．
したがって割り込みハンドラの登録ルーチンにより作成したハンドラを登録する．
この際，NICドライバのプライベート構造体を参照できるようにするため，
NICドライバの初期化処理の関数内でNICのデバイス構造体を指定して登録する．
これにより，空いているIRQ番号に割り込みハンドラを登録し，
呼び出せるようになる．
\subsection{受信バッファの作成}
% \subsection{割り込み間隔の調整}
% 割り込みジェネレータにおいて割り込みの間隔をユーザが
% 調整できるような機能を実装する．
% 具体的には連続で割り込みを発生させる際の
% 割り込みの間隔を調整できるようにする．

\chapter{評価}\label{estimaion}
\section{目的}
Mintを用いたNICドライバの割り込みデバッグ支援環境についての評価を行う．
実際のNICを用いた割り込み処理と本研究のデバッグ支援環境の割り込み処理を
比べてどの程度の差があるのかを評価する．
これにより，バグが発生した際と同程度の計算機の状態であることを示す．
\section{項目}
評価の項目について以下に示し，説明する．
\begin{enumerate}
    \item 割り込み間隔の評価\\
        どれだけ短い間隔で連続の割り込みが発生させられるかを評価する．
        具体的には，デバッグ支援OSからデバッグ対象OSへ間隔を調整して
        割り込みを発生させ，どの程度の短さまで正常に割り込みが処理
        されるのかを評価するものである．
    \item CPU負荷の評価\\
        NICを使った実際の割り込み処理と比べて，どの程度のCPU負荷がかかって
        いるのかを評価する．
        具体的には，NICを用いた割り込み処理のCPU負荷を調査し，
        本研究のデバッグ支援環境を用いた割り込み処理のCPUが
        実際の割り込み処理のCPU負荷にどれだけ近付いているかを調査する．
\end{enumerate}
\section{割り込み間隔の評価}
    \subsection{方法}
    未着手
    \subsection{結果と考察}
    未着手
\section{CPU負荷の評価}
    \subsection{方法}
    未着手
    \subsection{結果と考察}
    未着手
\chapter{おわりに}\label{conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{enumerate}
    \item 本論文の流れを示す．
    \item Mintを用いたデバッグ支援環境の有用性を示す．
    \item 本研究ではNICドライバの割り込み処理に，Mintを用いた
        デバッグ支援環境を適用させたことを示す．
    \item 残された課題について述べる．
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\acknowledgment\label{acknowledgement} % 謝辞
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

(一例)
本研究を進めるにあたり，懇切丁寧なご指導をしていただきました
乃村能成准教授に心より感謝の意を表します．
また，研究活動において，数々のご指導やご助言を与えていただいた
谷口秀夫教授，山内利宏准教授に心から感謝申し上げます．
また，日頃の研究活動において，お世話になりました研究室の
皆様に感謝いたします．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 参考文献

% bibtex を使って埋める
% https://github.com/nomlab/nompedia/wiki/tex--index#user-content-pbibtex%25E3%2581%25AE%25E4%25BD%25BF%25E3%2581%2584%25E6%2596%25B9

% \bibliographystyle{tipsj}    % 情報処理学会形式(旧)
\bibliographystyle{ipsjunsrt} % 情報処理学会形式(新)
\bibliography{mybibdata}


\end{document}
